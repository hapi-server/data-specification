<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>HAPI-data-access-spec-dev</title>
  <link id="favicon" rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%220.9em%22 font-size=%22100%22>📖</text></svg>">
  <style>
    #toc {
      font-size: 85%;
      width: 15em;
      position: fixed;
      min-height: 100%;
      max-height: 100%;
      overflow-x: hidden;
      overflow-y: auto;
      padding-left: 0.75em ;
      padding-right: 1em;
      font-family: "Open Sans";
    }
    
    #toc ol {
      list-style-type: decimal;
      padding-inline-start: 1em;
    }
    
    #toc a {
      text-decoration: none;
    }
    
    #display {
      width: 100%;
      margin-left: 14em;
      max-height: 100%;
      min-height: 100%;
      overflow-x: hidden;
      overflow-y: auto;
      padding-left: 1em;
      padding-right: 1em;
      border-left: 1px solid rgb(240,240,240);
      font-family: "Open Sans";
    }
    
    .title {
      text-align: center;
      font-size: 250%;
      font-weight: bold;
      color: black;
      margin-bottom: 0;
    }
    
    .subtitle {
      text-align: center;
      font-size: 150%;
      font-weight: bold;
      color: black;
      margin-top: 0.2em;
    }
    
    .hanchor {
      text-decoration: none;
      color: inherit;
    }
    
    h1 {
      color: darkblue;
      border-bottom: 2px solid darkblue;
      cursor: arrow;
    }
    
    h2 {
      border-bottom: 1px solid black;
    }
    
    h3 {
      border-bottom: 1px dotted black;
    }
    
    ul {
      margin-left: 1em;
      padding-left: 1em;
    }
    
    a {
      text-decoration: none;
    }
    
    /* Fenced code blocks have form <pre><code>...</code></pre> */
    pre > code {
      background-color: rgba(0,0,0,0);
      font-size: 1.25em;
    }
    
    code {
      background-color: rgba(0,0,0,.03);
      border-radius: 0px;
      font-size: 1.2em;
    }
    
    code.language-Python {
      background-color: rgba(0,0,0,0);
      font-size: 1.2em;
    }
    
    pre {
      border-left: 3px solid black;
      background-color: rgba(0,0,0,.03);
      padding: 0.5em;
      margin-left: 1em;
      margin-right: 1em;
      line-height: 1.5;
      overflow-x: scroll;
    }
    
    pre.language-Python {
      border-left: 5px solid blue;
      padding: 0.5em;
      margin-left: 1em;
      margin-right: 1em;
      line-height: 1.5;
    }
    
    details > summary {
      font-weight: bold;
    }
    
    details[open] {
      border: 1px solid black;
      padding: 1em;
    }    
    /* 
      A span with class 'katex' wraps all equations. A span with class
      katex-display wraps block equations and a span with class katex.
    */
    .katex { 
      font-size: inherit !important;
    }
    
    .katex-display {
      text-align: center;
      margin: 1em;
      font-size: 1.1em !important;
    }
    
    @media print {
    
      * { overflow: visible !important; } 
    
      body, html {
        margin: 0.5in;
        color: #000;
        height: auto;
        background-color: #fff;
        border: none;
        display: inline;
      }
    
      h1,h2,h3,h4,h5,h6 {page-break-before: avoid;}
    
      .title {
        page-break-before: always;
        margin-top: 0;
      }
    
      #toc {
        font-size: 100%;
        margin: 0;
        width: 100%;
        overflow-y: hidden;
        padding-left: 0;
        padding-right: 0;
      }
    
      #display {
        width: 100%;
        padding-left: 0;
        padding-right: 0;
        border: none;
        overflow-wrap: break-word;
      }
    }
  </style>
  <link id="hljs-css" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css">
</head>

<body style="display: flex;min-width: 50%;max-height:100%;">
  <div id="toc">
    <ol>
      <li><a number="1" href="#hapi-data-access-specification">HAPI Data Access Specification</a></li>
      <li><a number="2" href="#significant-changes-to-specification">Significant Changes to Specification</a></li>
      <ol>
        <li><a number="2.1" href="#api-changes-from-version-2-to-3">API Changes from version 2 to 3</a></li>
        <li><a number="2.2" href="#schema-changes-from-version-2-to-3">Schema Changes from version 2 to 3</a></li>
      </ol>
      <li><a number="3" href="#introduction">Introduction</a></li>
      <li><a number="4" href="#endpoints">Endpoints</a></li>
      <ol>
        <li><a number="4.1" href="#hapi">hapi</a></li>
        <li><a number="4.2" href="#about">about</a></li>
        <li><a number="4.3" href="#capabilities">capabilities</a></li>
        <li><a number="4.4" href="#catalog">catalog</a></li>
        <li><a number="4.5" href="#info">info</a></li>
        <li><a number="4.6" href="#data">data</a></li>
        <ol style="display: none;">
          <li><a number="4.6.1" href="#data-stream-content">Data Stream Content</a></li>
        </ol>
      </ol>
      <li><a number="5" href="#implications-of-the-hapi-data-model">Implications of the HAPI data model</a></li>
      <li><a number="6" href="#cross-origin-resource-sharing">Cross Origin Resource Sharing</a></li>
      <li><a number="7" href="#hapi-status-codes">HAPI Status Codes</a></li>
      <ol>
        <li><a number="7.1" href="#hapi-client-error-handling">HAPI Client Error Handling</a></li>
      </ol>
      <li><a number="8" href="#representation-of-time">Representation of Time</a></li>
      <ol>
        <li><a number="8.1" href="#incoming-time-values">Incoming time values</a></li>
        <li><a number="8.2" href="#outgoing-time-values">Outgoing time values</a></li>
      </ol>
      <li><a number="9" href="#additional-keyword-value-pairs">Additional Keyword / Value Pairs</a></li>
      <li><a number="10" href="#more-about">More About</a></li>
      <ol>
        <li><a number="10.1" href="#data-types">Data Types</a></li>
        <li><a number="10.2" href="#the-size-attribute">The ‘size’ Attribute</a></li>
        <li><a number="10.3" href="#-fill-values">‘fill’ Values</a></li>
        <li><a number="10.4" href="#examples">Examples</a></li>
      </ol>
      <li><a number="11" href="#security-notes">Security Notes</a></li>
      <li><a number="12" href="#adoption">Adoption</a></li>
      <li><a number="13" href="#references">References</a></li>
      <li><a number="14" href="#contact">Contact</a></li>
      <li><a number="15" href="#appendix-a-sample-landing-page">Appendix A: Sample Landing Page</a></li>
      <li><a number="16" href="#appendix-b-json-object-of-hapi-response-and-error-codes">Appendix B: JSON Object of HAPI Response and Error Codes</a></li>
    </ol>
  </div>
  <div id="display">
    <div class="section">
    </div>
    <div class="section">
      <h1><a name="hapi-data-access-specification" number="1" class="hanchor" href="#hapi-data-access-specification">1 HAPI Data Access Specification</a></h1>
      <p>Version 3.0.0-dev | Heliophysics Data and Model Consortium (HDMC) |</p>
      <p><strong>This is the development version of the HAPI Data Access Specification.</strong></p>
      <p>The most recent stable release is <a href="https://github.com/hapi-server/data-specification/tree/master/hapi-2.1.1">Version 2.1.1</a>.</p>
    </div>
    <div class="section">
      <h1><a name="significant-changes-to-specification" number="2" class="hanchor" href="#significant-changes-to-specification">2 Significant Changes to Specification</a></h1>
    </div>
    <div class="section">
      <h2><a name="api-changes-from-version-2-to-3" number="2.1" class="hanchor" href="#api-changes-from-version-2-to-3">2.1 API Changes from version 2 to 3</a></h2>
      <p>Non-backward compatible changes to the request interface in HAPI 3.0:</p>
      <ol>
        <li>The URL parameter <code>id</code> was replaced with <code>dataset</code>. </li>
        <li><code>time.min</code> and <code>time.max</code> were replaced with <code>start</code> and <code>stop</code>, respectively.</li>
        <li>Addition of a new endpoint, “<a href="#about">about</a>“, for server description metadata.</li>
      </ol>
      <p>HAPI 3 servers must accept both the old and new parameter names, but HAPI 2 servers will respond with an error if the new URL parameter names are used. These changes were discussed in issue <a href="https://github.com/hapi-server/data-specification/issues/77">#77</a>. Eventually, the now-deprecated older names will no longer be supported.</p>
    </div>
    <div class="section">
      <h2><a name="schema-changes-from-version-2-to-3" number="2.2" class="hanchor" href="#schema-changes-from-version-2-to-3">2.2 Schema Changes from version 2 to 3</a></h2>
      <ol>
        <li>Ability to specify time-varying bins</li>
        <li>Ability to use JSON references in <code>info</code> response</li>
        <li>Ability to indicate a units schema (if one is being used for <code>units</code> strings)</li>
      </ol>
    </div>
    <div class="section">
      <h1><a name="introduction" number="3" class="hanchor" href="#introduction">3 Introduction</a></h1>
      <p>This document describes the Heliophysics Application Programmer’s Interface (HAPI) specification, which is an API, metadata, and data streaming format specification for time-series data. The intent of this specification is to enhance interoperability among time series data providers. The HAPI specification describes the lowest common denominator of services that any provider of time series data could implement. Many data providers already offer access to their data holdings through some kind of API. The intention of this specification is to capture features available from many existing data providers and to codify implementation details so that providers can use the same API. This will make it possible to obtain time series science data content seamlessly from many sources and using a variety of programming languages.</p>
      <p>This document is intended to be used by two groups of people: first by data providers who want to make time-series data available through a HAPI server, and second by data users who want to understand how data is made available from a HAPI server, or perhaps to write client software to obtain data from an existing HAPI server.</p>
      <p>HAPI constitutes a minimum but complete set of capabilities needed for a server to allow access to the time series data values within one or more data collections. Because of its focus on data access, the HAPI metadata standard is not intended for complex search and discovery. However, the metadata schema allows ways to indicate where further descriptive details for any dataset could be found.</p>
      <p>The HAPI API is based on REpresentational State Transfer (REST) principles, which emphasize that URLs are stable endpoints through which clients can request data. Because it is based on well-established HTTP request and response rules, a wide range of HTTP clients can be used to interact with HAPI servers.</p>
      <p>The following definitions are provided first to ensure clarity in ensuing descriptions.</p>
      <ul>
        <li><strong>parameter</strong> – a measured science quantity or a related ancillary quantity at one instant in time; may be scalar or a multi-dimensional array as a function; must have units and must have a fill value that indicates no measurement was available or absent information.</li>
        <li><strong>record</strong> – all the parameters together with associated with a time value.</li>
        <li><strong>dataset</strong> – a collection of uniform records. A HAPI service presents a dataset as a seamless collection of time-ordered records, offering a way to retrieve the parameters without knowledge of the actual storage details.</li>
        <li><strong>catalog</strong> - a collection of datasets. </li>
        <li><strong>request parameter</strong> – keywords that appear after the ‘?’ in a URL with a GET request.</li>
      </ul>
      <p>Consider this example GET request (see <a href="#significant-changes-to-specification">change notes</a>):</p>
      <pre><code>http://server/hapi/data?dataset=alpha&amp;start=2016-07-13&amp;stop=2016-07-14</code></pre>
      <p>The three request parameters are <code>dataset</code> (corresponding to the identifier of the dataset), <code>start</code>, and <code>stop</code>. They have values of <code>alpha</code>, <code>2016-07-13</code>, and <code>2016-07-14</code>, respectively. This document will always use the full phrase “request parameter” to refer to these URL elements to make a clear distinction between a parameter in a dataset.</p>
      <p>In the above URL, the segment represented as <code>server</code> captures the hostname for the HAPI server as well as any prefix path elements before the required <code>hapi</code> element. For example, in <code>http://example.com/public/data/hapi</code> the <code>server</code> element is <code>example.com/public/data</code>.</p>
    </div>
    <div class="section">
      <h1><a name="endpoints" number="4" class="hanchor" href="#endpoints">4 Endpoints</a></h1>
      <p>The HAPI specification consists of five required endpoints that give clients a precise way to first determine the data holdings of the server and then to request data. The functionality of the required endpoints is as follows:</p>
      <ol>
        <li>
          <p> <code>/hapi/capabilities</code> lists the output formats the server can stream (<code>csv</code>, <code>binary</code>, or <code>json</code>, <a href="#data-stream-content">described below</a>).</p>
        </li>
        <li>
          <p> <code>/hapi/about</code> lists the server id and title, contact information, and a brief description of the datasets served (this endpoint is new in the version 3 HAPI specification).</p>
        </li>
        <li>
          <p> <code>/hapi/catalog</code> lists the catalog of available datasets; each dataset is associated with a unique id and may optionally have a title.</p>
        </li>
        <li>
          <p> <code>/hapi/info</code> lists information about a dataset with a given id; a primary component of the description is the list of parameters in the dataset.</p>
        </li>
        <li>
          <p> <code>/hapi/data</code> streams data for a dataset of a given id and over a given time range; a subset of parameters in a dataset may be requested (default is all parameters).</p>
        </li>
      </ol>
      <p>There is also an optional landing page endpoint <code>/hapi</code> that returns human-readable HTML. Although there is recommended content for this landing page, it is not essential to the functioning of the server.</p>
      <p>The five required endpoints are REST-style in that the resulting HTTP response is the complete response for each endpoint. In particular, the <code>/data</code> endpoint does not only give URLs or links to the data, but rather streams the data contained in the HTTP response. The full specification for each endpoint is described below.</p>
      <p>All endpoints must have a <code>/hapi</code> path element in the URL and only the <code>/info</code> and <code>/data</code> endpoints take query parameters:</p>
      <pre><code>http://server/hapi (Optional HTML landing page)
http://server/hapi/capabilities
http://server/hapi/about
http://server/hapi/catalog
http://server/hapi/info?dataset=...[&amp;...]
http://server/hapi/data?dataset=...&amp;...</code></pre>
      <p>Requests to a HAPI server must not change the server state. Therefore, all HAPI endpoints must respond only to HTTP HEAD and GET requests.</p>
      <p>The input specification for each endpoint (the request parameters and their allowed values) must be strictly enforced by the server. HAPI servers must not add additional request parameters beyond those in the specification. If a request URL contains any unrecognized or misspelled request parameters, a HAPI server must respond with an error status. (See <a href="#hapi-status-codes">HAPI Status Codes</a> for more details.) The principle being followed is that the server must not silently ignore unrecognized request parameters because this would falsely indicate to clients that the request parameter was understood and was taken into account when creating the output. That is if a server is given a request parameter that is not part of the HAPI specification, such as <code>averagingInterval=5s</code>, the server must report an error for two reasons: 1. additional request parameters are not allowed, and 2. the server will not do any averaging.</p>
      <p>The outputs from a HAPI server to the <code>about</code>, <code>catalog</code>, <code>capabilities</code>, and <code>info</code> endpoints are JSON objects, the formats of which are described below in the sections detailing each endpoint. The <code>data</code> endpoint must be able to deliver Comma Separated Value (CSV) data following the RFC 4180 standard [1], but may optionally deliver data content in binary format or JSON format. The response stream formats are described in the <a href="#data-stream-content">Data Stream Content</a> section.</p>
      <p>The following is the detailed specification for the five main HAPI endpoints as well as the optional landing page endpoint.</p>
    </div>
    <div class="section">
      <h2><a name="hapi" number="4.1" class="hanchor" href="#hapi">4.1 hapi</a></h2>
      <p>This root endpoint is optional and should provide a human-readable landing page for the server. Unlike the other endpoints, there is no strict definition for the output, but if present, it should include a brief description of the data and other endpoints, and links to documentation on how to use the server. An example landing page that can be easily customized for a new server is given in <a href="#appendix-a-sample-landing-page">Appendix A</a>.</p>
      <p>There are many options for landing page content, such as an HTML view of the catalog, or links to commonly requested data.</p>
      <p><strong>Sample Invocation</strong></p>
      <pre><code>http://server/hapi</code></pre>
      <p><strong>Request Parameters</strong></p>
      <p>None</p>
      <p><strong>Response</strong></p>
      <p>The response is in HTML format with a mime type of <code>text/html</code>. The content for the landing page is not strictly defined but should look something like the example below.</p>
      <p><strong>Example</strong></p>
      <p>Retrieve the landing page for this server.</p>
      <pre><code>http://server/hapi</code></pre>
      <p><strong>Example Response:</strong></p>
      <p>See <a href="#appendix-a-sample-landing-page">Appendix A</a>.</p>
    </div>
    <div class="section">
      <h2><a name="about" number="4.2" class="hanchor" href="#about">4.2 about</a></h2>
      <p><strong>Sample Invocation</strong></p>
      <pre><code>http://server/hapi/about</code></pre>
      <p><strong>Request Parameters</strong></p>
      <p>None</p>
      <p><strong>Response</strong></p>
      <p>The server’s response to this endpoint must be in JSON format [3] as defined by RFC-7159, and the response must indicate a mime type of <code>application/json</code>. Server attributes are described using keyword-value pairs, with the required and optional keywords described in the following table.</p>
      <p><strong>Capabilities Object</strong></p>
      <table>
        <thead>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>id</td>
            <td>string</td>
            <td><strong>Required</strong> A unique ID for the server. Ideally, this ID has the organization name in it, e.g., NASA/SPDF/SSCWeb, NASA/SPDF/CDAWeb, INTERMAGNET, UniversityIowa/VanAllen, LASP/TSI, etc.</td>
          </tr>
          <tr>
            <td>title</td>
            <td>string</td>
            <td><strong>Required</strong> A short human-readable name for the server. The suggested maximum length is 40 characters.</td>
          </tr>
          <tr>
            <td>contact</td>
            <td>string</td>
            <td><strong>Required</strong> Contact information or email address for server issues. HAPI clients should show this contact information when it is certain that an error is due to a problem with the server (as opposed to the client). Ideally, the HAPI client recommends that the user check their connection and try again at least once before contacting the server contact.</td>
          </tr>
          <tr>
            <td>description</td>
            <td>string</td>
            <td><strong>Optional</strong> A brief description of what type of data the server provides.</td>
          </tr>
          <tr>
            <td>contactID</td>
            <td>string</td>
            <td><strong>Optional</strong> The identifier in the discovery system for information about the contact. For example, a SPASE ID of a person identified in the <code>contact</code> string.</td>
          </tr>
          <tr>
            <td>citation</td>
            <td>string</td>
            <td><strong>Optional</strong> How to cite data server. An actionable DOI is preferred (e.g., <a href="https://doi.org/">https://doi.org/</a>…). This <code>citation</code> differs from the <code>citation</code> in an <code>/info</code> response. Here the citation is for the entity that maintains the data server.</td>
          </tr>
        </tbody>
      </table>
      <p><strong>Example</strong></p>
      <pre><code>http://server/hapi/about</code></pre>
      <p><strong>Example Response:</strong></p>
      <pre class="language-javascript"><code class="language-javascript">{
  <span class="hljs-string">"HAPI"</span>: <span class="hljs-string">"3.0"</span>,
  <span class="hljs-string">"status"</span>: { <span class="hljs-string">"code"</span>: <span class="hljs-number">1200</span>, <span class="hljs-string">"message"</span>: <span class="hljs-string">"OK"</span>},
  <span class="hljs-string">"id"</span>: <span class="hljs-string">"TestData3.0"</span>,
  <span class="hljs-string">"title"</span>: <span class="hljs-string">"HAPI 3.0 Test Data and Metadata"</span>,
  <span class="hljs-string">"contact"</span>: <span class="hljs-string">"examplel@example.org"</span>,
}</code></pre>
    </div>
    <div class="section">
      <h2><a name="capabilities" number="4.3" class="hanchor" href="#capabilities">4.3 capabilities</a></h2>
      <p>This endpoint describes relevant implementation capabilities for this server. Currently, the only possible variability from server to server is the list of output formats that are supported.</p>
      <p>A server must support <code>csv</code> output format, but <code>binary</code> output format and <code>json</code> output may optionally be supported. Servers may support custom output formats, which would be advertised here. All custom formats listed by a server must begin with the string <code>x_</code> to indicate that they are custom formats and avoid naming conflicts with possible future additions to the specification.</p>
      <p><strong>Sample Invocation</strong></p>
      <pre><code>http://server/hapi/capabilities</code></pre>
      <p><strong>Request Parameters</strong></p>
      <p>None</p>
      <p><strong>Response</strong></p>
      <p>The server’s response to this endpoint must be in JSON format [3] as defined by RFC 7159, and the response must indicate a mime type of <code>application/json</code>. Server capabilities are described using keyword-value pairs, with <code>outputFormats</code> being the only keyword currently in use.</p>
      <p><strong>Capabilities Object</strong></p>
      <table>
        <thead>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>HAPI</td>
            <td>string</td>
            <td><strong>Required</strong> The version number of the HAPI specification this description complies with.</td>
          </tr>
          <tr>
            <td>status</td>
            <td>Status object</td>
            <td><strong>Required</strong> Server response status for this request.</td>
          </tr>
          <tr>
            <td>outputFormats</td>
            <td>string array</td>
            <td><strong>Required</strong> The list of output formats the server can emit. All HAPI servers must support at least <code>csv</code> output format, with <code>binary</code> and <code>json</code> output formats being optional.</td>
          </tr>
        </tbody>
      </table>
      <p><strong>Example</strong></p>
      <p>Retrieve a listing of capabilities of this server.</p>
      <pre><code>http://server/hapi/capabilities</code></pre>
      <p><strong>Example Response:</strong></p>
      <pre class="language-javascript"><code class="language-javascript">{
  <span class="hljs-string">"HAPI"</span>: <span class="hljs-string">"2.1"</span>,
  <span class="hljs-string">"status"</span>: { <span class="hljs-string">"code"</span>: <span class="hljs-number">1200</span>, <span class="hljs-string">"message"</span>: <span class="hljs-string">"OK"</span>},
  <span class="hljs-string">"outputFormats"</span>: [ <span class="hljs-string">"csv"</span>, <span class="hljs-string">"binary"</span>, <span class="hljs-string">"json"</span> ]
}</code></pre>
      <p>If a server only reports an output format of <code>csv</code>, then requesting <code>binary</code> data should cause the server to respond with an error status. There is a specific HAPI error code for this, namely <code>1409 "Bad request - unsupported output format"</code> with a corresponding HTTP response code of 400. <a href="#hapi-status-codes">See below</a> for more about error responses.</p>
    </div>
    <div class="section">
      <h2><a name="catalog" number="4.4" class="hanchor" href="#catalog">4.4 catalog</a></h2>
      <p>This endpoint provides a list of datasets available from this server.</p>
      <p><strong>Sample Invocation</strong></p>
      <pre><code>http://server/hapi/catalog</code></pre>
      <p><strong>Request Parameters</strong></p>
      <p>None</p>
      <p><strong>Response</strong></p>
      <p>The response is in JSON format [3] as defined by RFC-7159 and has a mime type of <code>application/json</code>. The catalog is a simple listing of identifiers for the datasets available through the server providing the catalog. Additional metadata about each dataset is available through the <code>info</code> endpoint (described below). The catalog takes no query parameters and always lists the full catalog.</p>
      <p><strong>Catalog Object</strong></p>
      <table>
        <thead>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>HAPI</td>
            <td>string</td>
            <td><strong>Required</strong> The version number of the HAPI specification this description complies with.</td>
          </tr>
          <tr>
            <td>status</td>
            <td>object</td>
            <td><strong>Required</strong> Server response status for this request. (see <a href="#hapi-status-codes">HAPI Status Codes</a>)</td>
          </tr>
          <tr>
            <td>catalog</td>
            <td>array of Dataset</td>
            <td><strong>Required</strong> A list of datasets available from this server.</td>
          </tr>
        </tbody>
      </table>
      <p><strong>Dataset Object</strong></p>
      <table>
        <thead>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>id</td>
            <td>string</td>
            <td><strong>Required</strong> The computer-friendly identifier (see below) that the host system uses to locate the dataset. Each identifier must be unique within the HAPI server where it is provided.</td>
          </tr>
          <tr>
            <td>title</td>
            <td>string</td>
            <td><strong>Optional</strong> A short human-readable name for the dataset. If none is given, it defaults to the id. The suggested maximum length is 40 characters.</td>
          </tr>
        </tbody>
      </table>
      <p><strong>Example</strong></p>
      <p>Retrieve a listing of datasets shared by this server.</p>
      <pre><code>http://server/hapi/catalog</code></pre>
      <p><strong>Example Response:</strong></p>
      <pre class="language-javascript"><code class="language-javascript">{
   <span class="hljs-string">"HAPI"</span> : <span class="hljs-string">"2.1"</span>,
   <span class="hljs-string">"status"</span>: { <span class="hljs-string">"code"</span>: <span class="hljs-number">1200</span>, <span class="hljs-string">"message"</span>: <span class="hljs-string">"OK"</span>},
   <span class="hljs-string">"catalog"</span> : 
   [
      {<span class="hljs-string">"id"</span>: <span class="hljs-string">"ACE_MAG"</span>, <span class="hljs-attr">title</span>:<span class="hljs-string">"ACE Magnetometer data"</span>},
      {<span class="hljs-string">"id"</span>: <span class="hljs-string">"data/IBEX/ENA/AVG5MIN"</span>},
      {<span class="hljs-string">"id"</span>: <span class="hljs-string">"data/CRUISE/PLS"</span>},
      {<span class="hljs-string">"id"</span>: <span class="hljs-string">"any_identifier_here"</span>}
   ]
}</code></pre>
      <p class="">The identifiers must be unique within a single HAPI server. Also, dataset identifiers in the catalog should be stable over time. Including rapidly changing version numbers or other revolving elements (dates, processing ids, etc.) in the datasets identifiers should be avoided. The intent of the HAPI specification is to allow data to be referenced using RESTful URLs that have a reasonable lifetime.</p>
      <p class="active">These identifiers must be limited to the set of characters including upper and lower case letters, numbers, and the following characters: comma, colon, slash, minus and plus. See <a href="https://github.com/hapi-server/data-specification/issues/89">89</a> for a discussion of this.</p>
    </div>
    <div class="section">
      <h2><a name="info" number="4.5" class="hanchor" href="#info">4.5 info</a></h2>
      <p>This endpoint provides a data header for a given dataset. The header is expressed in JSON format [3] as defined by RFC-7159 and has a mime type of <code>application/json</code>. The focus of the header is to provide enough metadata to allow automated reading of the data content that is streamed via the <code>data</code> endpoint. The header must include a list of the parameters in the dataset, as well as the date range covered by the dataset. There are also optional metadata elements for capturing other high-level information such as a brief description of the dataset, the typical cadence of the data, and ways to learn more about a dataset. The table below lists all required and optional dataset attributes in the header.</p>
      <p>Servers may include additional custom (server-specific) keywords or keyword/value pairs in the header, but any non-standard keywords must begin with the prefix <code>x_</code>.</p>
      <p>Each parameter listed in the header must itself be described by specific metadata elements and a separate table below describes the required and optional parameter attributes.</p>
      <p>By default, the parameter list in the <code>info</code> response will include <em>all</em> parameters available in the dataset. However, a client may request a header for just a subset of the parameters. The subset of interest is specified as a comma-separated list via the request parameter called <code>parameters</code>. (Note that the client would have to obtain the parameter names from a prior request.) There must not be any duplicates in the subset list, and the subset list must be arranged according to the ordering in the original, full list of parameters. The reduced header is useful because it is also possible to request a subset of parameters when asking for data (see the <code>data</code> endpoint), and a reduced header can be requested that would then match the subset of parameters in the data. This correspondence of reduced header and reduced data ensures that a data request for a subset of parameters can be interpreted properly even if additional subset requests are made with no header. (Although a way to write a client as safe as possible would be to always request the header, and rely on the parameter ordering in the header to guide interpretation of the data column ordering.)</p>
      <p>Note that the <code>data</code> endpoint may optionally prepend the <code>info</code> header to the data stream (at the user’s request). In cases where the <code>data</code> endpoint response includes a header followed by <code>csv</code> or <code>binary</code> data, the header must always end with a newline. This enables the end of the JSON header to be more easily detected when it is in front of a binary data response. One good way to detect the end of the header is to calculate the number of open braces minus the number of closed braces. The last character in the header is the newline following the closing brace that makes open braces minus closed braces equal to zero. For <code>json</code> output, the header and data are all within a single JSON entity, and so newlines are not necessary.</p>
      <p><strong>Sample Invocation</strong></p>
      <pre><code>http://server/hapi/info?dataset=ACE_MAG</code></pre>
      <p><strong>Request Parameters</strong></p>
      <table>
        <thead>
          <tr>
            <th>Name</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>dataset</td>
            <td><strong>Required</strong> The identifier for the dataset (see <a href="#significant-changes-to-specification">change notes</a>)</td>
          </tr>
          <tr>
            <td>parameters</td>
            <td><strong>Optional</strong> A subset of the parameters to include in the header.</td>
          </tr>
        </tbody>
      </table>
      <p><strong>Response</strong></p>
      <p>The response is in JSON format [3] and provides metadata about one dataset.</p>
      <p><strong>Info Object</strong></p>
      <table>
        <thead>
          <tr>
            <th>Dataset Attribute</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>HAPI</td>
            <td>string</td>
            <td><strong>Required</strong> The version number of the HAPI specification with which this description complies.</td>
          </tr>
          <tr>
            <td>status</td>
            <td>object</td>
            <td><strong>Required</strong> Server response status for this request. (see <a href="#hapi-status-codes">HAPI Status Codes</a>)</td>
          </tr>
          <tr>
            <td>format</td>
            <td>string</td>
            <td><strong>Required</strong> (when the header is prefixed to data stream) Format of the data as <code>csv</code> or <code>binary</code> or <code>json</code>.</td>
          </tr>
          <tr>
            <td>parameters</td>
            <td>array of Parameter</td>
            <td><strong>Required</strong> Description of the parameters in the data.</td>
          </tr>
          <tr>
            <td>startDate</td>
            <td>string</td>
            <td><strong>Required</strong> <a href="#representation-of-time">Restricted ISO 8601</a> date/time of first record of data in the entire dataset.</td>
          </tr>
          <tr>
            <td>stopDate</td>
            <td>string</td>
            <td><strong>Required</strong> <a href="#representation-of-time">Restricted ISO 8601</a> date/time of the last record of data in the entire dataset. For actively growing datasets, the end date can be approximate, but it is the server’s job to report an accurate end date.</td>
          </tr>
          <tr>
            <td>timeStampLocation</td>
            <td>string</td>
            <td><strong>Optional</strong> Indicates the positioning of the timestamp within the measurement window. Must be one of <code>begin</code>, <code>center</code>, <code>end</code> or <code>other</code>. <strong>If this attribute is absent, clients are to assume a default value of <code>center</code>,</strong> which is meant to indicate the exact middle of the measurement window. A value of <code>other</code> indicates that the location of the time stamp in the measurement window is either more complex than the options here, or it is not known. See also <a href="https://github.com/hapi-server/data-specification/wiki/implementation-notes">HAPI convention notes</a>. (Note: version 2.0 indicated that these labels were in all upper case. With release 2.1 and beyond, servers should use all lower case. Clients, however, need to be able to handle both all upper case and all lower case versions of these labels.)</td>
          </tr>
          <tr>
            <td>cadence</td>
            <td>string</td>
            <td><strong>Optional</strong> Time difference between records as an ISO 8601 duration. This is meant as a guide to the nominal cadence of the data and not a precise statement about the time between measurements. See also <a href="https://github.com/hapi-server/data-specification/wiki/implementation-notes">HAPI convention notes</a>.</td>
          </tr>
          <tr>
            <td>sampleStartDate</td>
            <td>string</td>
            <td><strong>Optional</strong> <a href="#representation-of-time">Restricted ISO 8601</a> date/time of the start of a sample time period for a dataset, where the time period must contain a manageable, representative example of valid, non-fill data. <strong>Required</strong> if <code>sampleStopDate</code> given.</td>
          </tr>
          <tr>
            <td>sampleStopDate</td>
            <td>string</td>
            <td><strong>Optional</strong> <a href="#representation-of-time">Restricted ISO 8601</a> date/time of the end of a sample time period for a dataset, where the time period must contain a manageable, representative example of valid, non-fill data. <strong>Required</strong> if <code>sampleStartDate</code> given.</td>
          </tr>
          <tr>
            <td>description</td>
            <td>string</td>
            <td><strong>Optional</strong> A brief description of the dataset.</td>
          </tr>
          <tr>
            <td>unitsSchema</td>
            <td>string</td>
            <td><strong>Optional</strong> The name of the units convention that describes how to parse all <code>units</code> strings in this dataset. Currently, the only allowed values are: <code>udunits2</code>, <code>astropy3</code>, and <code>cdf-cluster</code>. See above for where to find out about each of these convenstions. The list of allowed units specifications is expected to grow to include other well documented units standards.</td>
          </tr>
          <tr>
            <td>resourceURL</td>
            <td>string</td>
            <td><strong>Optional</strong> URL linking to more detailed information about this dataset.</td>
          </tr>
          <tr>
            <td>resourceID</td>
            <td>string</td>
            <td><strong>Optional</strong> An identifier by which this data is known in another setting, for example, the SPASE ID.</td>
          </tr>
          <tr>
            <td>creationDate</td>
            <td>string</td>
            <td><strong>Optional</strong> <a href="#representation-of-time">Restricted ISO 8601</a> date/time of the dataset creation.</td>
          </tr>
          <tr>
            <td>citation</td>
            <td>string</td>
            <td><strong>Optional</strong> How to cite the data set. An actionable DOI is preferred (e.g., <a href="https://doi.org/">https://doi.org/</a>…). Note that there is a <code>citation</code> in an <code>/about</code> response that is focused on the server implementation, but this <code>citation</code> is focused on one dataset.</td>
          </tr>
          <tr>
            <td>modificationDate</td>
            <td>string</td>
            <td><strong>Optional</strong> <a href="#representation-of-time">Restricted ISO 8601</a> date/time of the modification of the any content in the dataset.</td>
          </tr>
          <tr>
            <td>contact</td>
            <td>string</td>
            <td><strong>Optional</strong> Relevant contact person name (and possibly contact information) for science questions about the dataset.</td>
          </tr>
          <tr>
            <td>contactID</td>
            <td>string</td>
            <td><strong>Optional</strong> The identifier in the discovery system for information about the contact. For example, the SPASE ID or ORCID of the person.</td>
          </tr>
        </tbody>
      </table>
      <p>One optional attirbute is <code>unitsSchema</code>. This allows a server to specify, for each dataset, what convention is followed for the <code>units</code> strings in the parameters of the dataset. Currently, the only allowed values for <code>unitsSchema</code> are: <code>udunits2</code>, <code>astropy3</code>, and <code>cdf-cluster</code>. These represent the currently known set of units conventions that also have software available for parsing and interpreting units strings. Note that only major version numbers (if available) are indicated in the convention name. It is expected that this list will grow over time as needed. Current locations of the official definitions and software tools for interpreting the various units conventions are in the following table:</p>
      <table>
        <thead>
          <tr>
            <th>Convention Name</th>
            <th>Current URL</th>
            <th>Description (context help if link is broken)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>udunits2</code></td>
            <td><a href="https://www.unidata.ucar.edu/software/udunits/udunits-current/doc/udunits/udunits2.html">https://www.unidata.ucar.edu/software/udunits/udunits-current/doc/udunits/udunits2.html</a></td>
            <td>Unidata from UCAR; a C library for units of physical quantities</td>
          </tr>
          <tr>
            <td><code>astropy3</code></td>
            <td><a href="https://docs.astropy.org/en/stable/units/">https://docs.astropy.org/en/stable/units/</a></td>
            <td>package inside <code>astropy</code> that handles defining, converting between, and performing arithmetic with physical quantities, such as meters, seconds, Hz, etc</td>
          </tr>
          <tr>
            <td><code>cdf-cluster</code></td>
            <td><a href="https://caa.esac.esa.int/documents/DS-QMW-TN-0010.pdf">https://caa.esac.esa.int/documents/DS-QMW-TN-0010.pdf</a> which is referenced on this page: <a href="https://www.cosmos.esa.int/web/csa/documentation">https://www.cosmos.esa.int/web/csa/documentation</a></td>
            <td>conventions created and used by ESA’s Cluster mission</td>
          </tr>
        </tbody>
      </table>
      <!--
These are not confirmed, since they don't have updated or stable info available online. The PRBEM info is old, and until very recently, the MMS info was behind a password, so it's not clear if it is in a permanent location.
| ```cdf-mms```      | https://lasp.colorado.edu/galaxy/display/mms/Units+of+Measure | conventions created and used by NASA's Magnetic Multiscale (MMS) mission |
| ```cdf-prbem```    | https://craterre.onera.fr/prbem/home.html | units for particles and fields from the Panel on Radiation Belt Environment Modeling (PRBEM) |
-->
      <p><strong>Parameter</strong></p>
      <p>The focus of the header is to list the parameters in a dataset. The first parameter in the list must be a time value. This time column serves as the independent variable for the dataset. The time column parameter may have any name, but its type must be <code>isotime</code> and there must not be any fill values in the data stream for this column. Note that the HAPI specification does not clarify if the time values given are the start, middle, or end of the measurement intervals. There can be other parameters of type <code>isotime</code> in the parameter list. The table below describes the Parameter items and their allowed types.</p>
      <table>
        <thead>
          <tr>
            <th>Parameter Attribute</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>name</td>
            <td>string</td>
            <td><strong>Required</strong> A short name for this parameter. It is recommended that all parameter names start with a letter or underscore, followed by letters, underscores, or numbers. This allows the parameter names to become variable names in computer languages. Parameter names in a dataset must be unique, and names are not allowed to differ only by having a different case. Note that because parameter names can appear in URLs that can serve as permanent links to data, changing them will have negative implications, such as breaking links to data. Therefore, parameter names should be stable over time.</td>
          </tr>
          <tr>
            <td>type</td>
            <td>string</td>
            <td><strong>Required</strong> One of <code>string</code>, <code>double</code>, <code>integer</code>, <code>isotime</code>. Binary content for <code>double</code> is always 8 bytes in IEEE 754 format, <code>integer</code> is 4 bytes signed little-endian. There is no default length for <code>string</code> and <code>isotime</code> types. <a href="#data-types">See below</a> for more information on data types.</td>
          </tr>
          <tr>
            <td>length</td>
            <td>integer</td>
            <td><strong>Required</strong> For type <code>string</code> and <code>isotime</code>; <strong>not allowed for others</strong>. The maximum number of bytes that the string may contain. If the response format is binary and a string has fewer than this maximum number of bytes, the string must be padded with ASCII null bytes.</td>
          </tr>
          <tr>
            <td>size</td>
            <td>array of integers</td>
            <td><strong>Required</strong> For array parameters; <strong>not allowed for others</strong>. Must be a 1-D array whose values are the number of array elements in each dimension of this parameter. For example, <code>"size"=[7]</code> indicates that the value in each record is a 1-D array of length 7. For the <code>csv</code> and <code>binary</code> output, there must be 7 columns for this parameter – one column for each array element, effectively unwinding this array. The <code>json</code> output for this data parameter must contain an actual JSON array (whose elements would be enclosed by <code>[ ]</code>). For arrays 2-D and higher, such as <code>"size"=[2,3]</code>, the later indices are the fastest moving, so that the CSV and binary columns for such a 2 by 3 would be <code>[0,0]</code>, <code>[0,1]</code>, <code>[0,2]</code> and then <code>[1,0]</code>, <code>[1,1]</code>, <code>[1,2]</code>.Note that <code>"size":[1]</code> is allowed but discouraged, because clients may interpret it as either an array of length 1 or as a scalar. Similarly, an array size of 1 in any dimension is discouraged, because of ambiguity in the way clients would treat this structure. Array sizes of arbitrary dimensionality are allowed, but from a practical view, clients typically support up to 3D or 4D arrays. <a href="#the-size-attribute">See below</a> for more about array sizes.</td>
          </tr>
          <tr>
            <td>units</td>
            <td>string OR array of string</td>
            <td><strong>Required</strong> The units for the data values represented by this parameter. For dimensionless quantities, the value can be the literal string <code>"dimensionless"</code> or the special JSON value <code>null</code>. Note that an empty string <code>""</code> is not allowed. For <code>isotime</code> parameters, the units must be <code>UTC</code>. If a parameter is a scalar, the units must be a single string. For an array parameter, a <code>units</code> value that is a single string means that the same units apply to all elements in the array. If the elements in the array parameter have different units, then <code>units</code> can be an array of strings to provide specific units strings for each element in the array. Individual values for elements in the array can also be <code>"dimensionless"</code> or <code>null</code> (but not an empty string) to indicate no units for that element. The shape of such a <code>units</code> array must match the shape given by the <code>size</code> of the parameter, and the ordering of multi-dimensional arrays of unit strings is as discussed in the <code>size</code> attribute definition above. See below (the example responses to an <code>info</code> query) for examples of a single string and string array units.</td>
          </tr>
          <tr>
            <td>fill</td>
            <td>string</td>
            <td><strong>Required</strong> A fill value indicates no valid data is present. If a parameter has no fill present for any records in the dataset, this can be indicated by using a JSON null for this attribute as in <code>"fill": null</code> <a href="#fill-values">See below</a> for more about fill values, <strong>including the issues related to specifying numeric fill values as strings</strong>. Note that since the primary time column cannot have fill values, it must specify <code>"fill": null</code> in the header.</td>
          </tr>
          <tr>
            <td>description</td>
            <td>string</td>
            <td><strong>Optional</strong> A brief, one-sentence description of the parameter.</td>
          </tr>
          <tr>
            <td>label</td>
            <td>string OR array of string</td>
            <td><strong>Optional</strong> A word or very short phrase that could serve as a label for this parameter (as on a plot axis or in a selection list of parameters). Intended to be less cryptic than the parameter name. If the parameter is a scalar, this label must be a single string. If the parameter is an array, a single string label or an array of string labels are allowed. A single label string will be applied to all elements in the array, whereas an array of label strings specifies a different label string for each element in the array parameter. The shape of the array of label strings must match the <code>size</code> attribute, and the ordering of multi-dimensional arrays of label strings is as discussed in the <code>size</code> attribute definition above. No <code>null</code> values or the empty string <code>""</code> values are allowed in an array of label strings. See below (the example responses to an <code>info</code> query) for examples of a single string and string array labels.</td>
          </tr>
          <tr>
            <td>bins</td>
            <td>array of Bins object</td>
            <td><strong>Optional</strong> For array parameters, each object in the <code>bins</code> array corresponds to one of the dimensions of the array and describes values associated with each element in the corresponding dimension of the array. The table below describes all required and optional attributes within each <code>bins</code> object. If the parameter represents a 1-D frequency spectrum, the <code>bins</code> array will have one object describing the frequency values for each frequency bin. Within that object, the <code>centers</code> attribute points to an array of values to use for the central frequency of each channel, and the <code>ranges</code> attribute specifies a range (min to max) associated with each channel. At least one of these must be specified. The bins object has a required <code>units</code> keyword (any string value is allowed), and <code>name</code> is also required. See examples below for a parameter with bins describing an energy spectrum. Note that for 2D or higher bins, each bin array is still a 1D array – having bins with 2D (or higher) dependencies is not currently supported.</td>
          </tr>
        </tbody>
      </table>
      <p><strong>Bins Object</strong></p>
      <p>The bins attribute of a parameter is an array of JSON objects. These objects have the attributes described below. <strong>NOTE: Even though</strong> <code>ranges</code> <strong>and</strong> <code>centers</code> <strong>are marked as required, only one of the two must be specified.</strong></p>
      <table>
        <thead>
          <tr>
            <th>Bins Attribute</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>name</td>
            <td>string</td>
            <td><strong>Required</strong> Name for the dimension (e.g. “Frequency”).</td>
          </tr>
          <tr>
            <td>centers</td>
            <td>array of n doubles</td>
            <td><strong>Required</strong> The centers of each bin.</td>
          </tr>
          <tr>
            <td>ranges</td>
            <td>array of n array of 2 doubles</td>
            <td><strong>Required</strong> The boundaries for each bin.</td>
          </tr>
          <tr>
            <td>units</td>
            <td>string</td>
            <td><strong>Required</strong> The units for the bin ranges and/or center values.</td>
          </tr>
          <tr>
            <td>label</td>
            <td>string</td>
            <td><strong>Optional</strong> A label appropriate for a plot (use if <code>name</code> is not appropriate)</td>
          </tr>
          <tr>
            <td>description</td>
            <td>string</td>
            <td><strong>Optional</strong> Brief comment explaining what the bins represent.</td>
          </tr>
        </tbody>
      </table>
      <p>Note that some dimensions of a multi-dimensional parameter may not represent binned data. Each dimension must be described in the <code>bins</code> object, but any dimension not representing binned data should indicate this by using <code>'"centers": null'</code> and not including the <code>'ranges'</code> attribute.</p>
      <p>The data given for <code>centers</code> and <code>ranges</code> must not contain any <code>null</code> or missing values. The number of valid numbers in the <code>centers</code> array and the number of valid min/max pairs in the <code>ranges</code> array must match the size of the parameter dimension being described. So this is not allowed:</p>
      <pre><code>centers = [2, null, 4],
ranges = [[1,3], null, [3,5]]</code></pre>
      <p>If the bin centers or ranges change with time, then having static values for the centers or ranges cannot in the <code>info</code> response is inadequate. See the section below on time varying bins for how to handle this situation.</p>
      <p><strong>Example</strong></p>
      <p>These examples show an <code>info</code> response for a hypothetical magnetic field dataset.</p>
      <pre><code>http://server/hapi/info?dataset=ACE_MAG</code></pre>
      <p><strong>Example Response:</strong></p>
      <pre class="language-json"><code class="language-json">{  <span class="hljs-attr">"HAPI"</span>: <span class="hljs-string">"3.0"</span>,
   <span class="hljs-attr">"status"</span>: { <span class="hljs-attr">"code"</span>: <span class="hljs-number">1200</span>, <span class="hljs-attr">"message"</span>: <span class="hljs-string">"OK"</span>},
   <span class="hljs-attr">"startDate"</span>: <span class="hljs-string">"1998-001Z"</span>,
   <span class="hljs-attr">"stopDate"</span> : <span class="hljs-string">"2017-100Z"</span>,
   <span class="hljs-attr">"parameters"</span>: [
       { <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Time"</span>,
         <span class="hljs-attr">"type"</span>: <span class="hljs-string">"isotime"</span>,
         <span class="hljs-attr">"units"</span>: <span class="hljs-string">"UTC"</span>,
         <span class="hljs-attr">"fill"</span>: <span class="hljs-literal">null</span>,
         <span class="hljs-attr">"length"</span>: <span class="hljs-number">24</span> },
       { <span class="hljs-attr">"name"</span>: <span class="hljs-string">"radial_position"</span>,
         <span class="hljs-attr">"type"</span>: <span class="hljs-string">"double"</span>,
         <span class="hljs-attr">"units"</span>: <span class="hljs-string">"km"</span>,
         <span class="hljs-attr">"fill"</span>: <span class="hljs-literal">null</span>,
         <span class="hljs-attr">"description"</span>: <span class="hljs-string">"radial position of the spacecraft"</span>,
         <span class="hljs-attr">"label"</span>: <span class="hljs-string">"R Position"</span>},
       { <span class="hljs-attr">"name"</span>: <span class="hljs-string">"quality_flag"</span>,
         <span class="hljs-attr">"type"</span>: <span class="hljs-string">"integer"</span>,
         <span class="hljs-attr">"units"</span>: <span class="hljs-string">"none"</span>,
         <span class="hljs-attr">"fill"</span>: <span class="hljs-literal">null</span>,
         <span class="hljs-attr">"description "</span>: <span class="hljs-string">"0=OK and 1=bad"</span>},
       { <span class="hljs-attr">"name"</span>: <span class="hljs-string">"mag_GSE"</span>,
         <span class="hljs-attr">"type"</span>: <span class="hljs-string">"double"</span>,
         <span class="hljs-attr">"units"</span>: <span class="hljs-string">"nT"</span>,
         <span class="hljs-attr">"fill"</span>: <span class="hljs-string">"-1e31"</span>,
         <span class="hljs-attr">"size"</span> : [<span class="hljs-number">3</span>],
         <span class="hljs-attr">"description"</span>: <span class="hljs-string">"hourly average Cartesian magnetic field in nT in GSE"</span>,
         <span class="hljs-attr">"label"</span>: <span class="hljs-string">"B field in GSE"</span>}
   ]
}</code></pre>
      <p>This example included the optional <code>label</code> attribute for some parameters. The use of a single string for the <code>units</code> and <code>label</code> of the array parameter <code>mag_GSE</code> indicates that all elements of the array have the same units and label. The next example shows a header for a magnetic field dataset where the vector components are assigned distinct units and labels.</p>
      <pre class="language-json"><code class="language-json">{  <span class="hljs-attr">"HAPI"</span>: <span class="hljs-string">"3.0"</span>,
   <span class="hljs-attr">"status"</span>: { <span class="hljs-attr">"code"</span>: <span class="hljs-number">1200</span>, <span class="hljs-attr">"message"</span>: <span class="hljs-string">"OK"</span>},
   <span class="hljs-attr">"startDate"</span>: <span class="hljs-string">"1998-001Z"</span>,
   <span class="hljs-attr">"stopDate"</span> : <span class="hljs-string">"2017-100Z"</span>,
   <span class="hljs-attr">"parameters"</span>: [
       { <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Time"</span>,
         <span class="hljs-attr">"type"</span>: <span class="hljs-string">"isotime"</span>,
         <span class="hljs-attr">"units"</span>: <span class="hljs-string">"UTC"</span>,
         <span class="hljs-attr">"fill"</span>: <span class="hljs-literal">null</span>,
         <span class="hljs-attr">"length"</span>: <span class="hljs-number">24</span> },
       { <span class="hljs-attr">"name"</span>: <span class="hljs-string">"radial_position"</span>,
         <span class="hljs-attr">"type"</span>: <span class="hljs-string">"double"</span>,
         <span class="hljs-attr">"units"</span>: <span class="hljs-string">"km"</span>,
         <span class="hljs-attr">"fill"</span>: <span class="hljs-literal">null</span>,
         <span class="hljs-attr">"description"</span>: <span class="hljs-string">"radial position of the spacecraft"</span>,
         <span class="hljs-attr">"label"</span>: <span class="hljs-string">"R Position"</span>},
       { <span class="hljs-attr">"name"</span>: <span class="hljs-string">"quality_flag"</span>,
         <span class="hljs-attr">"type"</span>: <span class="hljs-string">"integer"</span>,
         <span class="hljs-attr">"units"</span>: <span class="hljs-string">"none"</span>,
         <span class="hljs-attr">"fill"</span>: <span class="hljs-literal">null</span>,
         <span class="hljs-attr">"description "</span>: <span class="hljs-string">"0=OK and 1=bad "</span> },
       { <span class="hljs-attr">"name"</span>: <span class="hljs-string">"mag_GSE"</span>,
         <span class="hljs-attr">"type"</span>: <span class="hljs-string">"double"</span>,
         <span class="hljs-attr">"units"</span>: [<span class="hljs-string">"nT"</span>,<span class="hljs-string">"degrees"</span>, <span class="hljs-string">"degrees"</span>],
         <span class="hljs-attr">"fill"</span>: <span class="hljs-string">"-1e31"</span>,
         <span class="hljs-attr">"size"</span> : [<span class="hljs-number">3</span>],
         <span class="hljs-attr">"description"</span>: <span class="hljs-string">"B field as magnitude and two angles theta (colatitude) and phi (longitude)"</span>,
         <span class="hljs-attr">"label"</span>: [<span class="hljs-string">"B Magnitude"</span>, <span class="hljs-string">"theta"</span>, <span class="hljs-string">"phi"</span>] }
   ]
}</code></pre>
      <p>This example is nearly the same as the previous <code>info</code> header, but the <code>mag_GSE</code> parameter is different. It is given as a magnitude and two direction angles, and it also illustrates the use of an array of strings for the <code>units</code> and <code>label</code>. Each element in the string array applies to the corresponding element in the <code>mag_GSE</code> data array.</p>
      <p>When a scalar <code>units</code> value is given for an array parameter, the scalar is assumed to apply to all elements in the array – a kind of broadcast application of the single value to all values in the array. For multi-dimensional arrays, the broadcast applies to all elements in every dimension. A partial broadcast to only one dimension in the array is not allowed. Either a full set of unit strings are given to describe every element in the multi-dimensional array, or a single value is given to apply to all elements. This allows for the handling of special cases while keeping the specification simple. The same broadcast rules govern labels.</p>
      <p>Here are some example fragments from a parameter definition showing what is allowed and not allowed for <code>units</code> and <code>label</code> values.</p>
      <p><strong>OK</strong> (scalar units applied to all 6 elements in the array; unique label for each element)</p>
      <pre><code>"type": "double",
"size": [2,3],
"units": "m/s",
"label": [["V1x","V1y","V1z"],["V2x","V2y","V2z"]]</code></pre>
      <p><strong>Also OK</strong> (array of length 1 is treated like scalar; not preferred but allowed)</p>
      <pre><code>"type": "double",
"size": [2,3]
"units": ["m/s"],
"label": [["V1x","V1y","V1z"],["V2x","V2y","V2z"]]</code></pre>
      <p><strong>OK</strong> (scalar for <code>units</code> and for <code>label</code> applies to all elements in the array)</p>
      <pre><code>"type": "double",
"size": [2,3]
"units": "m/s",
"label": "velocity",</code></pre>
      <p><strong>Not OK</strong> (array size does not match parameter size – must specify all <code>units</code> elements if not just giving a scalar)</p>
      <pre><code>"type": "double",
"size": [2,3],
"units": ["m/s","m/s","km/s"],
"label": [["V1x","V1y","V1z"],["V2x","V2y","V2z"]]</code></pre>
      <p><strong>OK</strong> (all elements are properly given their own <code>units</code> string)</p>
      <pre><code>"type": "double",
"size": [2,3],
"units": [["m/s","m/s","km/s"],["m/s","m/s","km/s"]],
"label": [["V1x","V1y","V1z"],["V2x","V2y","V2z"]]</code></pre>
      <p><strong>Not OK</strong> (<code>units</code> array size does not match parameter size)</p>
      <pre><code>"type": "double",
"size": [2,3]
"units": ["m/s",["m/s","m/s","km/s"]],
"label": [["V1x","V1y","V1z"],["V2x","V2y","V2z"]]</code></pre>
      <p><strong>Subsetting the Parameters</strong></p>
      <p>Clients may request a response that includes only a subset of the parameters), or a data stream for a subset of parameters (via the <code>data</code> endpoint, described next), the logic on the server is the same in terms of what dataset parameters are included in the response. The primary time parameter (always required to be the first parameter in the list) is always included, even if not requested. These examples clarify the way a server must respond to various types of dataset parameter subsetting requests:</p>
      <ul>
        <li>
          <p><strong>request:</strong> do not ask for any specific parameters (i.e., there is no request parameter called ‘parameters’);<br> <strong>example:</strong> <code>http://server/hapi/data?dataset=MY_MAG_DATA&amp;start=1999Z&amp;stop=2000Z</code><br> <strong>response:</strong> all columns</p>
        </li>
        <li>
          <p><strong>request:</strong> ask for just the primary time parameter;<br> <strong>example:</strong> <code>http://server/hapi/data?dataset=MY_MAG_DATA&amp;parameters=Epoch&amp;start=1999Z&amp;stop=2000Z</code>
            <strong>response:</strong> just the primary time column
          </p>
        </li>
        <li>
          <p><strong>request:</strong> ask for a single parameter other than the primary time column (like ‘parameters=Bx’);<br> <strong>example:</strong> <code>http://server/hapi/data?dataset=MY_MAG_DATA&amp;parameters=Bx&amp;start=1999Z&amp;stop=2000Z</code><br> <strong>response:</strong> primary time column and the one requested data column</p>
        </li>
        <li>
          <p><strong>request:</strong> ask for two or more parameters other than the primary time column;<br> <strong>example:</strong> <code>http://server/hapi/data?dataset=MY_MAG_DATA&amp;parameters=Bx,By&amp;start=1999Z&amp;stop=2000Z</code><br> <strong>response:</strong> primary time column followed by the requested parameters in the order they occurred in the original, non-subsetted dataset header (not in the order of the subset request)</p>
        </li>
        <li>
          <p><strong>request:</strong> including the <code>parameters</code> option, but not specifying any parameter names;<br> <strong>example:</strong> <code>http://server/hapi/data?dataset=MY_MAG_DATA&amp;parameters=&amp;start=1999Z&amp;stop=2000Z</code><br> <strong>response:</strong> the is an error condition; server should report a user input error</p>
        </li>
      </ul>
      <p>Note that the order in which parameters are listed in the request must not differ from the order that they appear in the response. For a data set with parameters <code>Time,param1,param2,param3</code> this subset request</p>
      <p><code>?dataset=ID&amp;parameters=Time,param1,param3</code></p>
      <p>is acceptable, because <code>param1</code> is before <code>param3</code> in the <code>parameters</code> array (as determined by the <code>/info</code> response). However, asking for a subset of parameters in a different order, as in</p>
      <p><code>?dataset=ID&amp;parameters=Time,param3,param1</code></p>
      <p>is not allowed, and servers must respond with an error status. See <a href="#hapi-status-codes">HAPI Status Codes</a> for more about error conditions and codes.</p>
      <p><strong>Using JSON References to Better Capture Repeated Metadata</strong></p>
      <p>If the same information appears more than once within the <code>info</code> response, it is better to represent this in a structured way, rather than to copy and paste duplicate information. Consider a dataset with two parameters – one for the measurement values, and one for the uncertainties. If the two parameters both have <code>bins</code> associated with them, the bin definitions would likely be identical. Having each <code>bins</code> entity refer back to a pre-defined, single entity ensures that the bins values are indeed identical, and it also more readily communicates the connection to users, who otherwise would have to do a value-by-value comparison to see if the bin values are indeed the same.</p>
      <p>JSON has a built-in mechanism for handling references. HAPI utilizes a subset of these features, focusing on the simple aspects that are implemented in many existing JSON parsers. Also, using only simple features makes it easier for users to implement custom parsers. Note that familiarity with the full description of JSON references [5], is helpful in understanding the use of references in HAPI described below.</p>
      <p>JSON objects placed within a <code>definitions</code> block can be pointed to using the <code>$ref</code> notation. We begin with an example. This <code>definitions</code> block contains this object called <code>angle_bins</code> that can be referred to using the JSON syntax <code>#/definitions/angle_bins</code></p>
      <pre class="language-json"><code class="language-json">{
  <span class="hljs-attr">"definitions"</span> : {
     <span class="hljs-attr">"pitch_angle_bins"</span>: {
         <span class="hljs-attr">"name"</span> : <span class="hljs-string">"angle_bins"</span>,
         <span class="hljs-attr">"ranges"</span>: [ [  <span class="hljs-number">0</span>,   <span class="hljs-number">30</span> ],
                     [  <span class="hljs-number">30</span>,  <span class="hljs-number">60</span> ],
                     [  <span class="hljs-number">60</span>,  <span class="hljs-number">90</span> ],
                     [  <span class="hljs-number">90</span>,  <span class="hljs-number">120</span> ],
                     [  <span class="hljs-number">120</span>, <span class="hljs-number">150</span> ],
                     [  <span class="hljs-number">150</span>, <span class="hljs-number">180</span> ]
                   ],
         <span class="hljs-attr">"units"</span>: <span class="hljs-string">"degrees"</span>,
         <span class="hljs-attr">"label"</span>: <span class="hljs-string">"Pitch Angle"</span>
      }
   }
}</code></pre>
      <p>Here is a parameter fragment showing the reference used in two places:</p>
      <pre class="language-json"><code class="language-json">{
   <span class="hljs-attr">"parameters"</span>: [
       { <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Time"</span>,
         <span class="hljs-attr">"type"</span>: <span class="hljs-string">"isotime"</span>,
         <span class="hljs-attr">"units"</span>: <span class="hljs-string">"UTC"</span>,
         <span class="hljs-attr">"fill"</span>: <span class="hljs-literal">null</span>,
         <span class="hljs-attr">"length"</span>: <span class="hljs-number">24</span>
       },
       { <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Protons_10_to_20_keV_pitch_angle_spectrogram"</span>,
         <span class="hljs-attr">"type"</span>: <span class="hljs-string">"double"</span>,
         <span class="hljs-attr">"units"</span>: <span class="hljs-string">"1/(cm^2 s^2 ster keV)"</span>,
         <span class="hljs-attr">"fill"</span>: <span class="hljs-string">"-1.0e38"</span>,
         <span class="hljs-attr">"size"</span>: [<span class="hljs-number">6</span>],
         <span class="hljs-attr">"bins"</span>: [
                  {<span class="hljs-attr">"$ref"</span> : <span class="hljs-string">"#/definitions/angle_bins"</span>}
                 ]
       },
       { <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Uncert_for_Protons_10_to_20_keV_pitch_angle_spectrogram"</span>,
         <span class="hljs-attr">"type"</span>: <span class="hljs-string">"double"</span>,
         <span class="hljs-attr">"units"</span>: <span class="hljs-string">"1/(cm^2 s^2 ster keV)"</span>,
         <span class="hljs-attr">"fill"</span>: <span class="hljs-string">"-1.0e38"</span>,
         <span class="hljs-attr">"size"</span>: [<span class="hljs-number">6</span>],
         <span class="hljs-attr">"bins"</span>: [
                  {<span class="hljs-attr">"$ref"</span> : <span class="hljs-string">"#/definitions/angle_bins"</span>}
                 ]

       }
   ]
}</code></pre>
      <p>The following rules govern the use of JSON references a HAPI info response.</p>
      <ol>
        <li>Anything referenced must appear in a top-level node named <code>definitions</code> (this is a JSON Schema convention [5] but a HAPI requirement).</li>
        <li>Objects in the <code>definitions</code> node may not contain references (JSON Schema [5] allows this, HAPI does not)</li>
        <li>Referencing by <code>id</code> is not allowed (JSON Schema [5] allows this, HAPI does not)</li>
        <li><code>name</code> may not be a reference (names must be unique anyway - this would make HAPI <code>info</code> potentially very confusing).</li>
      </ol>
      <p>By default, a server resolves these references and excludes the definitions node. Stated more directly, a server should not return a <code>definitions</code> block unless the request URL includes</p>
      <pre><code>resolve_references=false</code></pre>
      <p>in which case the response metadata should contain references to items in the <code>definitions</code> node. Note these constraints on what can be in the <code>definitions</code>:</p>
      <ol>
        <li>Any element found in the <code>definitions</code> node must be used somewhere in the full set of metadata. Note that this full metadata can be obtained via an <code>info</code> request or by a <code>data</code> request to which the header is prepended (using <code>include=header</code>).</li>
        <li>If an <code>info</code> request or a <code>data</code> request with <code>include=header</code> is for a <em>subset</em> of parameters (e.g., <code>/hapi/info?id=DATASETID&amp;parameters=p1,p2)</code>, the <code>definitions</code> node may contain objects that are not referenced in the metadata for the requested subset of parameters; removal of unused definitions is optional in this case.</li>
      </ol>
      <p>Here then is a complete example of an info response with references unresolved, showing a <code>definitions</code> block and the use of references. The <code>units</code> string is commonly used, so it is captured as a reference, as is the full bins definition. Note that this example shows how just a part of the <code>bins</code> object could be represented – the <code>centers</code> object in this case. The example is valid HAPI content, but normally, it would not make sense to use both of these approaches in a single <code>info</code> response.</p>
      <pre class="language-json"><code class="language-json">{
    <span class="hljs-attr">"HAPI"</span>: <span class="hljs-string">"3.0"</span>,
    <span class="hljs-attr">"status"</span>: {
        <span class="hljs-attr">"code"</span>: <span class="hljs-number">1200</span>,
        <span class="hljs-attr">"message"</span>: <span class="hljs-string">"OK"</span>
    },
    <span class="hljs-attr">"startDate"</span>: <span class="hljs-string">"2016-01-01T00:00:00.000Z"</span>,
    <span class="hljs-attr">"stopDate"</span>: <span class="hljs-string">"2016-01-31T24:00:00.000Z"</span>,
    <span class="hljs-attr">"definitions"</span>: {
        <span class="hljs-attr">"spectrum_units"</span>: <span class="hljs-string">"particles/(sec ster cm^2 keV)"</span>,
        <span class="hljs-attr">"spectrum_centers"</span>: [<span class="hljs-number">15</span>, <span class="hljs-number">25</span>, <span class="hljs-number">35</span>, <span class="hljs-number">45</span>],
        <span class="hljs-attr">"spectrum_bins"</span>: {
            <span class="hljs-attr">"name"</span>: <span class="hljs-string">"energy"</span>,
            <span class="hljs-attr">"units"</span>: <span class="hljs-string">"keV"</span>,
            <span class="hljs-attr">"centers"</span>: [<span class="hljs-number">15</span>, <span class="hljs-number">25</span>, <span class="hljs-number">35</span>, <span class="hljs-number">45</span>]
        }
    },
    <span class="hljs-attr">"parameters"</span>: [{
            <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Time"</span>,
            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"isotime"</span>,
            <span class="hljs-attr">"units"</span>: <span class="hljs-string">"UTC"</span>,
            <span class="hljs-attr">"fill"</span>: <span class="hljs-literal">null</span>,
            <span class="hljs-attr">"length"</span>: <span class="hljs-number">24</span>
        },
        {
            <span class="hljs-attr">"name"</span>: <span class="hljs-string">"proton_spectrum"</span>,
            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"double"</span>,
            <span class="hljs-attr">"size"</span>: [<span class="hljs-number">4</span>],
            <span class="hljs-attr">"units"</span>: {<span class="hljs-attr">"$ref"</span>: <span class="hljs-string">"#/definitions/spectrum_units"</span>},
            <span class="hljs-attr">"fill"</span>: <span class="hljs-string">"-1e31"</span>,
            <span class="hljs-attr">"bins"</span>: [{
                <span class="hljs-attr">"name"</span>: <span class="hljs-string">"energy"</span>,
                <span class="hljs-attr">"units"</span>: <span class="hljs-string">"keV"</span>,
                <span class="hljs-attr">"centers"</span>: {<span class="hljs-attr">"$ref"</span>: <span class="hljs-string">"#/definitions/spectrum_centers"</span>}
            }]
        },
        {
            <span class="hljs-attr">"name"</span>: <span class="hljs-string">"proton_spectrum2"</span>,
            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"double"</span>,
            <span class="hljs-attr">"size"</span>: [<span class="hljs-number">4</span>],
            <span class="hljs-attr">"units"</span>: {<span class="hljs-attr">"$ref"</span>: <span class="hljs-string">"#/definitions/spectrum_units"</span>},
            <span class="hljs-attr">"bins"</span>: [
                     {<span class="hljs-attr">"$ref"</span>: <span class="hljs-string">"#/definitions/spectrum_bins"</span>}
                    ]
        }
    ]
}</code></pre>
      <p><strong>Time Varying Bins</strong></p>
      <p>In some datasets, the bin centers and/or ranges may vary with time. The static values in the <code>bins</code> object definition for <code>ranges</code> or <code>centers</code> are fixed arrays and therefore cannot represent bin boundaries that change over time. As of HAPI 3.0, the <code>ranges</code> and <code>centers</code> objects can be, instead of a numeric array, a string value that is the name of another parameter in the dataset. This allows the <code>ranges</code> and <code>centers</code> objects to point to a parameter that is then to be treated as the source of numbers for the bin <code>centers</code> or <code>ranges</code>. The size of the target parameter must match that of the bins being represented. And of course, each record of data can contain a different value for the parameter, effectively allowing the bin <code>ranges</code> and <code>centers</code> to change potentially at every time step.</p>
      <p>This kind of complex data structure for binned data will require some corresponding complexity on clients reading the data, but that it outside the scope of this specification.</p>
      <p>The following example shows a dataset of multi-dimensional values: proton intensities over multiple energies and at multiple pitch angles. The data parameter name is <code>proton_spectrum</code>, and it has bins for both an energy dimension (16 different energy bins) and a pitch angle dimension (3 different pitch angle bins). For the bins in both of these dimensions, a parameter name is given instead of numeric values for the bin locations. The parameter <code>energy_centers</code> contains an array of 16 values at each time step, and these are to be interpreted as the time-varying centers of the energies. Likewise, there is a <code>pitch_angle_centers</code> parameter which serves as the source of numbers for the centers of the other bin dimension. There are also <code>ranges</code> parameters that are two-dimensional elements since each range consists of a high and low value.</p>
      <p>Note that the comments embedded in the JSON (with a prefix of “<code>//</code>“) are for human readers only since comments are not supported in JSON.</p>
      <pre><code>{
    "HAPI": "3.0",
    "status": {"code": 1200, "message": "OK"},
    "startDate": "2016-01-01T00:00:00.000Z",
    "stopDate": "2016-01-31T24:00:00.000Z",
    "parameters": 
        [ { "name": "Time",
            "type": "isotime",
            "units": "UTC",
            "fill": null,
            "length": 24
          },
          { "name": "proton_spectrum",
            "type": "double",
            "size": [16,3],
            "units": "particles/(sec ster cm^2 keV)",
            "fill": "-1e31",
            "bins":
            [
                { "name": "energy",
                  "units": "keV",
                  "centers": "energy_centers",
                  "ranges":  "energy_ranges"
                },
                { "name": "pitch_angle",
                  "units": "degrees",
                  "centers": "pitch_angle_centers",
                  "ranges":  "pitch_angle_ranges"
                }
            ]
          },
          {
            "name": "energy_centers",
            "type": "double",
            "size": [16], // Must match product of elements in #/proton_spectrum/size
            "units": "keV", // Should match #/proton_spectrum/units
            "fill": "-1e31" // Clients should interpret as meaning no measurement made in bin
          },
          { "name": "energy_ranges",
            "type": "double",
            "size": [16,2],
            "units": "keV", // Should match #/proton_spectrum/units
            "fill": "-1e31" // Clients should interpret as meaning no measurement made in bin
          },
          { "name": "pitch_angle_centers",
            "type": "double",
            "size": [3], // Must match product of elements in #/proton_spectrum/size
            "units": "degrees", // Should match #/proton_spectrum/units
            "fill": "-1e31" // Clients should interpret as meaning no measurement made in bin
          },
          { "name": "pitch_angle_ranges",
            "type": "double",
            "size": [3,2],
            "units": "degrees", // Should match #/proton_spectrum/units
            "fill": "-1e31" // Clients should interpret as meaning no measurement made in bin
          }
        ]
}</code></pre>
      <p><strong>Variations in Data Size over Time</strong></p>
      <p>If the size of a dimensions in a multi-dimensional parameter changes over time, the only way to represent this in HAPI is to define the parameter as having the largest potential <code>size</code>, and then using a <code>fill</code> value for any data elements which are no longer actually being provided. </p>
      <p>If this size-changing parameter has bins, then the number of bins would also presumably change over time. Servers can indicate the absence of one or more bins by using the time-varying bin mechanism described above and then providing all fill values for the <code>ranges</code> and <code>centers</code> of the records where those bins are absent.</p>
      <p>The following example shows a conceptual data block (not in HAPI format) where there is an array parameter whose values are in columns <code>d0</code> through <code>d3</code>. The corresponding bin centers are in the columns <code>c0</code> through <code>c3</code>. The data block shows what happens in the data if the size of the parameter changes from 4 to 3 after the third time step. The data values change to fill (-1.0E31 in this case), and the values for the centers also change to fill to indicate that the corresponding array elements are no longer valid elements in the array.</p>
      <pre><code>time                     data0 data1 data2 data3     center0 center1 center1 center3 
2019-01-01T14:10:30.5    1.2   3.4   5.4   8.9       10.0    20.0    30.0    40.0
2019-01-01T14:10:31.5    1.1   3.6   5.8   8.4       10.0    20.0    30.0    40.0
2019-01-01T14:10:32.5    1.4   3.8   5.9   8.3       10.0    20.0    30.0    40.0
2019-01-01T14:10:33.5    1.3   3.1   5.3   -1.0e31   15.0    25.0    35.0    -1.0e31
2019-01-01T14:10:34.5    1.2   3.0   5.4   -1.0e31   15.0    25.0    35.0    -1.0e31
2019-01-01T14:10:35.5    1.2   3.0   5.4   -1.0e31   15.0    25.0    35.0    -1.0e31</code></pre>
      <p>Note that if the fill value in the bin centers that indicates that this array element is gone, since just finding some fill values in the dat column would not necessarily indicate that the column was permanently gone, although from a practical perspective, having data values that are fill effectively conveys the same information.</p>
    </div>
    <div class="section">
      <h2><a name="data" number="4.6" class="hanchor" href="#data">4.6 data</a></h2>
      <p>Provides access to a dataset and allows for selecting time ranges and parameters to return. Data is returned as a CSV- [2], binary- JSON-stream. The <a href="#data-stream-content">Data Stream Content</a> section describes the stream structure and layout for each format.</p>
      <p>The resulting data stream can be thought of as a stream of records, where each record contains one value for each of the dataset parameters. Each data record must contain a data value or a fill value (of the same data type) for each parameter.</p>
      <p><strong>Request Parameters</strong></p>
      <p>Items with a * superscript in the following table have been modified from version 2 to 3; see <a href="#significant-changes-to-specification">change notes</a>.</p>
      <table>
        <thead>
          <tr>
            <th>Name</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>dataset<a href="#significant-changes-to-specification"><sup>&nbsp;*&nbsp;</sup></a></td>
            <td><strong>Required</strong> The identifier for the dataset.</td>
          </tr>
          <tr>
            <td>start<a href="#significant-changes-to-specification"><sup>&nbsp;*&nbsp;</sup></a></td>
            <td><strong>Required</strong> The inclusive begin time for the data to include in the response.</td>
          </tr>
          <tr>
            <td>stop<a href="#significant-changes-to-specification"><sup>&nbsp;*&nbsp;</sup></a></td>
            <td><strong>Required</strong> The exclusive end time for the data to include in the response.</td>
          </tr>
          <tr>
            <td>parameters</td>
            <td><strong>Optional</strong> A comma-separated list of parameters to include in the response. Default is all parameters.</td>
          </tr>
          <tr>
            <td>include</td>
            <td><strong>Optional</strong> Has one possible value of “header” to indicate that the info header should precede the data. The header lines will be prefixed with the “#“ character.</td>
          </tr>
          <tr>
            <td>format</td>
            <td><strong>Optional</strong> The desired format for the data stream. Possible values are “csv”, “binary”, and “json”.</td>
          </tr>
        </tbody>
      </table>
      <p><strong>Response</strong></p>
      <p>Response is in one of three formats: CSV format as defined by [2] with a mime type of <code>text/csv</code>; binary format where floating points number are in IEEE 754 [4] format and byte order is LSB and a mime type of <code>application/octet-stream</code>; JSON format with the structure as described below and a mime type of <code>application/json</code>. The default data format is CSV. See the <a href="#data-stream-content">Data Stream Content</a> section for more details.</p>
      <p>If the header is requested, then for binary and CSV formats, each line of the header must begin with a hash (#) character. For JSON output, no prefix character should be used, because the data object will just be another JSON element within the response. Other than the possible prefix character, the contents of the header should be the same as returned from the info endpoint. When a data stream has an attached header, the header must contain an additional “format” attribute to indicate if the content after the header is <code>csv</code>, <code>binary</code>, or <code>json</code>. Note that when a header is included in a CSV response, the data stream is not strictly in CSV format.</p>
      <p>The first parameter in the data must be a time column (type of <code>isotime</code>) and this must be the independent variable for the dataset. If a subset of parameters is requested, the time column is always provided, even if it is not requested.</p>
      <p>Note that the <code>start</code> request parameter represents an inclusive lower bound and <code>stop</code> request parameter is the exclusive upper bound. The server must return data records within these time constraints, i.e., no extra records outside the requested time range. This enables the concatenation of results from adjacent time ranges.</p>
      <p>There is an interaction between the <code>info</code> endpoint and the <code>data</code> endpoint because the header from the <code>info</code> endpoint describes the record structure of data emitted by the <code>data</code> endpoint. Thus after a single call to the <code>info</code> endpoint, a client could make multiple calls to the <code>data</code> endpoint (for multiple time ranges, for example) with the expectation that each data response would contain records described by the single call to the <code>info</code> endpoint. The <code>data</code> endpoint can optionally prefix the data stream with header information, potentially obviating the need for the <code>info</code> endpoint. But the <code>info</code> endpoint is useful in that it allows clients to learn about a dataset without having to make a data request.</p>
      <p>Both the <code>info</code> and <code>data</code> endpoints take an optional request parameter (recall the definition of request parameter in the introduction) called <code>parameters</code> that allows users to restrict the dataset parameters listed in the header and data stream, respectively. This enables clients (that already have a list of dataset parameters from a previous info or data request) to request a header for a subset of parameters that will match a data stream for the same subset of parameters. The parameters in the subset request must be ordered according to the original order of the parameters in the metadata, i.e., the subset can contain fewer parameters, but must not rearrange the order of any parameters. Duplicates are not allowed.</p>
      <p>Consider the following dataset header for a fictional dataset with the identifier <code>MY_MAG_DATA</code>.</p>
      <p>An <code>info</code> request for this dataset<a href="#major-api-changes"><sup>*</sup></a></p>
      <pre><code>http://server/hapi/info?dataset=MY_MAG_DATA</code></pre>
      <p>results in a header listing of all the dataset parameters:</p>
      <pre class="language-javascript"><code class="language-javascript">{  <span class="hljs-string">"HAPI"</span>: <span class="hljs-string">"3.0"</span>,
   <span class="hljs-string">"status"</span>: { <span class="hljs-string">"code"</span>: <span class="hljs-number">1200</span>, <span class="hljs-string">"message"</span>: <span class="hljs-string">"OK"</span>},
   <span class="hljs-string">"startDate"</span>: <span class="hljs-string">"2005-01-21T12:05:00.000Z"</span>,
   <span class="hljs-string">"stopDate"</span> : <span class="hljs-string">"2010-10-18T00:00:00Z"</span>,
   <span class="hljs-string">"parameters"</span>: [
       { <span class="hljs-string">"name"</span>: <span class="hljs-string">"Time"</span>,
         <span class="hljs-string">"type"</span>: <span class="hljs-string">"isotime"</span>,
         <span class="hljs-string">"units"</span>: <span class="hljs-string">"UTC"</span>,
         <span class="hljs-string">"fill"</span>: <span class="hljs-literal">null</span>,
         <span class="hljs-string">"length"</span>: <span class="hljs-number">24</span> },
       { <span class="hljs-string">"name"</span>: <span class="hljs-string">"Bx"</span>, <span class="hljs-string">"type"</span>: <span class="hljs-string">"double"</span>, <span class="hljs-string">"units"</span>: <span class="hljs-string">"nT"</span>, <span class="hljs-string">"fill"</span>: <span class="hljs-string">"-1e31"</span>},
       { <span class="hljs-string">"name"</span>: <span class="hljs-string">"By"</span>, <span class="hljs-string">"type"</span>: <span class="hljs-string">"double"</span>, <span class="hljs-string">"units"</span>: <span class="hljs-string">"nT"</span>, <span class="hljs-string">"fill"</span>: <span class="hljs-string">"-1e31"</span>},
       { <span class="hljs-string">"name"</span>: <span class="hljs-string">"Bz"</span>, <span class="hljs-string">"type"</span>: <span class="hljs-string">"double"</span>, <span class="hljs-string">"units"</span>: <span class="hljs-string">"nT"</span>, <span class="hljs-string">"fill"</span>: <span class="hljs-string">"-1e31"</span>},
    ]
}</code></pre>
      <p>An <code>info</code> request for a single parameter looks like this<a href="#major-api-changes"><sup>*</sup></a></p>
      <pre><code>http://server/hapi/info?dataset=MY_MAG_DATA&amp;parameters=Bx</code></pre>
      <p>and would result in the following header:</p>
      <pre class="language-javascript"><code class="language-javascript">{  <span class="hljs-string">"HAPI"</span>: <span class="hljs-string">"3.0"</span>,
   <span class="hljs-string">"status"</span>: { <span class="hljs-string">"code"</span>: <span class="hljs-number">1200</span>, <span class="hljs-string">"message"</span>: <span class="hljs-string">"OK"</span>},
   <span class="hljs-string">"startDate"</span>: <span class="hljs-string">"2005-01-21T12:05:00.000Z"</span>,
   <span class="hljs-string">"stopDate"</span> : <span class="hljs-string">"2010-10-18T00:00:00Z"</span>,
   <span class="hljs-string">"parameters"</span>: [
       { <span class="hljs-string">"name"</span>: <span class="hljs-string">"Time"</span>,
         <span class="hljs-string">"type"</span>: <span class="hljs-string">"isotime"</span>,
         <span class="hljs-string">"units"</span>: <span class="hljs-string">"UTC"</span>,
         <span class="hljs-string">"fill"</span>: <span class="hljs-literal">null</span>,
         <span class="hljs-string">"length"</span>: <span class="hljs-number">24</span> },
       { <span class="hljs-string">"name"</span>: <span class="hljs-string">"Bx"</span>, <span class="hljs-string">"type"</span>: <span class="hljs-string">"double"</span>, <span class="hljs-string">"units"</span>: <span class="hljs-string">"nT"</span>, <span class="hljs-string">"fill"</span>: <span class="hljs-string">"-1e31"</span> },
    ]
}</code></pre>
      <p>Note that the time parameter is included even though it was not requested.</p>
      <p>In this request<a href="#major-api-changes"><sup>*</sup></a></p>
      <pre><code>http://server/hapi/info?dataset=MY_MAG_DATA&amp;parameters=By,Bx</code></pre>
      <p>the parameters are out of order. So the server should respond with an error code. See <a href="#hapi-status-codes">HAPI Status Codes</a> for more about error conditions.</p>
    </div>
    <div class="section">
      <h3><a name="data-stream-content" number="4.6.1" class="hanchor" href="#data-stream-content">4.6.1 Data Stream Content</a></h3>
      <p>The three possible output formats are <code>csv</code>, <code>binary</code>, and <code>json</code>. A HAPI server must support <code>csv</code>, while <code>binary</code> and <code>json</code> are optional.</p>
      <p><strong>CSV Output</strong></p>
      <p>The format of the CSV stream should follow the guidelines for CSV data as described by RFC 4180 [2]. Each CSV record is one line of text, with commas between the values for each dataset parameter. Any value containing a comma must be surrounded with double quotes, and any double-quote within a value must be escaped by a preceding double quote. An array parameter (i.e., the value of a parameter within one record is an array) will have multiple columns resulting from placing each element in the array into its own column. For 1-D arrays, the ordering of the unwound columns is just the index ordering of the array elements. For 2-D arrays or higher, the right-most array index is the fastest moving index when mapping array elements to columns.</p>
      <p>It is up to the server to decide how much precision to include in the ASCII values when generating CSV output.</p>
      <p>Clients programs interpreting the HAPI CSV stream are encouraged to use existing CSV parsing libraries to be able to interpret the full range of possible CSV values, including quoted commas and escaped quotes. However, it is expected that a simple CSV parser would probably handle more than 90% of known cases.</p>
      <p><strong>Binary Output</strong></p>
      <p>The binary data output is best described as a binary translation of the CSV stream, with full numerical precision and no commas or newlines. Recall that the dataset header provides type information for each dataset parameter, and this definitively indicates the number of bytes and the byte structure of each parameter, and thus of each binary record in the stream. Array parameters are unwound in the same way for binary as for CSV data as described above. All numeric values are little-endian (LSB), integers are always signed and four-byte and floating-point values are always IEEE 754 double-precision values.</p>
      <p>Dataset parameters of type <code>string</code> and <code>isotime</code> (which are just strings of ISO 8601 dates) have a maximum length specified in the info header. This length indicates how many bytes to read for each string value. If the string content is less than the length, the remaining bytes must be padded with ASCII null bytes. If a string uses all the bytes specified in the length, no null terminator or padding is needed.</p>
      <p><strong>JSON Output</strong></p>
      <p>For the JSON output, an additional <code>data</code> element added to the header contains the array of data records. These records are very similar to the CSV output, except that strings must be quoted and arrays must be delimited with array brackets in standard JSON fashion. An example helps to illustrate what the JSON format looks like. Consider a dataset with four parameters: time, a scalar value, a 1-D array value with an array length of 3, and a string value. The header with the data object might look like this:</p>
      <pre class="language-javascript"><code class="language-javascript">{  <span class="hljs-string">"HAPI"</span>: <span class="hljs-string">"3.0"</span>,
   <span class="hljs-string">"status"</span>: { <span class="hljs-string">"code"</span>: <span class="hljs-number">1200</span>, <span class="hljs-string">"message"</span>: <span class="hljs-string">"OK"</span>},
   <span class="hljs-string">"startDate"</span>: <span class="hljs-string">"2005-01-21T12:05:00.000Z"</span>,
   <span class="hljs-string">"stopDate"</span> : <span class="hljs-string">"2010-10-18T00:00:00Z"</span>,
   <span class="hljs-string">"parameters"</span>: [
       { <span class="hljs-string">"name"</span>: <span class="hljs-string">"Time"</span>, <span class="hljs-string">"type"</span>: <span class="hljs-string">"isotime"</span>, <span class="hljs-string">"units"</span>: <span class="hljs-string">"UTC"</span>, <span class="hljs-string">"fill"</span>: <span class="hljs-literal">null</span>, <span class="hljs-string">"length"</span>: <span class="hljs-number">24</span> },
       { <span class="hljs-string">"name"</span>: <span class="hljs-string">"quality_flag"</span>, <span class="hljs-string">"type"</span>: <span class="hljs-string">"integer"</span>, <span class="hljs-string">"description"</span>: <span class="hljs-string">"0=ok; 1=bad"</span>, <span class="hljs-string">"fill"</span>: <span class="hljs-literal">null</span> },
       { <span class="hljs-string">"name"</span>: <span class="hljs-string">"mag_GSE"</span>, <span class="hljs-string">"type"</span>: <span class="hljs-string">"double"</span>, <span class="hljs-string">"units"</span>: <span class="hljs-string">"nT"</span>,  <span class="hljs-string">"fill"</span>: <span class="hljs-string">"-1e31"</span>, <span class="hljs-string">"size"</span> : [<span class="hljs-number">3</span>],
           <span class="hljs-string">"description"</span>: <span class="hljs-string">"hourly average Cartesian magnetic field in nT in GSE"</span> },
       { <span class="hljs-string">"name"</span>: <span class="hljs-string">"region"</span>, <span class="hljs-string">"type"</span>: <span class="hljs-string">"string"</span>, <span class="hljs-string">"length"</span>: <span class="hljs-number">20</span>, <span class="hljs-string">"fill"</span>: <span class="hljs-string">"???"</span>, <span class="hljs-string">"units"</span> : <span class="hljs-literal">null</span>}
   ],
<span class="hljs-string">"format"</span>: <span class="hljs-string">"json"</span>,
<span class="hljs-string">"data"</span> : [
[<span class="hljs-string">"2010-001T12:01:00Z"</span>,<span class="hljs-number">0</span>,[<span class="hljs-number">0.44302</span>,<span class="hljs-number">0.398</span>,-<span class="hljs-number">8.49</span>],<span class="hljs-string">"sheath"</span>],
[<span class="hljs-string">"2010-001T12:02:00Z"</span>,<span class="hljs-number">0</span>,[<span class="hljs-number">0.44177</span>,<span class="hljs-number">0.393</span>,-<span class="hljs-number">9.45</span>],<span class="hljs-string">"sheath"</span>],
[<span class="hljs-string">"2010-001T12:03:00Z"</span>,<span class="hljs-number">0</span>,[<span class="hljs-number">0.44003</span>,<span class="hljs-number">0.397</span>,-<span class="hljs-number">9.38</span>],<span class="hljs-string">"sheath"</span>],
[<span class="hljs-string">"2010-001T12:04:00Z"</span>,<span class="hljs-number">1</span>,[<span class="hljs-number">0.43904</span>,<span class="hljs-number">0.399</span>,-<span class="hljs-number">9.16</span>],<span class="hljs-string">"sheath"</span>]
]

}</code></pre>
      <p>The data element is a JSON array of records. Each record is itself an array of parameters. The time and string values are in quotes, and any data parameter in the record that is an array must be inside square brackets. This data element appears as the last JSON element in the header.</p>
      <p>The record-oriented arrangement of the JSON format is designed to allow a streaming client reader to begin reading (and processing) the JSON data stream before it is complete. Note also that servers can start streaming the data as soon as records are available. In other words, the JSON format can be read and written without first having to hold all the records in memory. This may require some custom elements in the JSON parser, but preserving this streaming capability is important for keeping the HAPI spec scalable. Note that if pulling all the data content into memory is not a problem, then ordinary JSON parsers will also have no trouble with this JSON arrangement.</p>
      <p><strong>Errors While Streaming Data</strong></p>
      <p>If the server encounters an error while streaming the data and can no longer continue, it will have to terminate the stream. The <code>status</code> code (both HTTP and HAPI) and message will already have been set in the header and is unlikely to represent the error. Clients will have to be able to detect an abnormally terminated stream and should treat this aborted condition the same as an internal server error. See <a href="#hapi-status-codes">HAPI Status Codes</a> for more about error conditions.</p>
      <p><strong>Time Range With No Data</strong></p>
      <p>If a request is made for a time range in which there are no data, the server must respond with an HTTP 200 status code. The HAPI <a href="#hapi-status-codes">status-code</a> must be either <code>HAPI 1201</code> (the explicit no-data code) or <code>HAPI 1200</code> (OK). While the more specific <code>HAPI 1201</code> code is preferred, servers may have a difficult time recognizing the lack of data before issuing the header, in which case the issuing of <code>HAPI 1200</code> and the subsequent absence of any data records communicates to clients that everything worked but no data was present in the given interval. Any response that includes a header (JSON always does, and CSV and binary when requested) must have this same HAPI status set in the header. For CSV or binary responses without a header, the message body should be empty to indicate no data records.</p>
      <p>This example clarifies the ideal case. If servers have no data, the OK header</p>
      <pre><code>HTTP/1.1 200 OK</code></pre>
      <p>is acceptable, but a more specific header</p>
      <pre><code>HTTP/1.1 200 OK HAPI 1201 - no data in the interval</code></pre>
      <p>is preferred if the server can detect in time that there is no data. This allows clients to verify that the empty body was intended.</p>
      <p><strong>Time Range With All Fill Values</strong></p>
      <p>If a request is made with a time range in which the response will contain all fill values, the server must respond with all fill values and not an empty body.</p>
      <p><strong>Examples</strong></p>
      <p>Two examples of data requests and responses are given – one with the header and one without.</p>
      <p><strong>1. Data with Header</strong></p>
      <p>Note that in the following request, the header is to be included, so the same header from the <code>info</code> endpoint will be prepended to the data but with a ‘#’ character as a prefix for every header line.</p>
      <pre><code>http://server/hapi/data?dataset=path/to/ACE_MAG&amp;start=2016-01-01Z&amp;stop=2016-02-01Z&amp;include=header</code></pre>
      <p>Response</p>
      <pre><code>#{
#  "HAPI": "3.0",
#  "status": { "code": 1200, "message": "OK"},
#  "format": "csv",
#  "startDate": "1998-001Z",
#  "stopDate" : "2017-001Z",
#  "parameters": [
#       { "name": "Time",
#         "type": "isotime",
#         "units": "UTC",
#         "fill": null,
#         "length": 24
#       },
#       { "name": "radial_position",
#         "type": "double",
#         "units": "km",
#         "fill": null,
#         "description": "radial position of the spacecraft"
#       },
#       { "name": "quality flag",
#         "type": "integer",
#         "units ": null,
#         "fill": null,
#         "description ": "0=OK and 1=bad " 
#       },
#       { "name": "mag_GSE",
#         "type": "double",
#         "units": "nT",
#         "fill": "-1e31",
#         "size" : [3],
#         "description": "hourly average Cartesian magnetic field in nT in GSE"
#       }
#   ]
#}
2016-01-01T00:00:00.000Z,6.848351,0,0.05,0.08,-50.98
2016-01-01T01:00:00.000Z,6.890149,0,0.04,0.07,-45.26
        ...
        ... 
2016-01-01T02:00:00.000Z,8.142253,0,2.74,0.17,-28.62</code></pre>
      <p><strong>2. Data Only</strong></p>
      <p>The following example is the same, except it lacks the request to include the header.</p>
      <pre><code>http://server/hapi/data?dataset=path/to/ACE_MAG&amp;start=2016-01-01&amp;stop=2016-02-01</code></pre>
      <p><strong>Example Response: Data Only</strong></p>
      <p>Consider a dataset that contains a time field, two scalar fields, and one array field of length 3. The response will have the form:</p>
      <pre><code>2016-01-01T00:00:00.000Z,6.848351,0,0.05,0.08,-50.98
2016-01-01T01:00:00.000Z,6.890149,0,0.04,0.07,-45.26
...
...
2016-01-01T02:00:00.000Z,8.142253,0,2.74,0.17,-28.62</code></pre>
      <p>Note that there is no leading row with column names. The RFC 4180 CSV standard [2] indicates that such a header row is optional. Leaving out this row avoids the complication of having to name individual columns representing array elements within an array parameter. Recall that an array parameter has only a single name. The place HAPI specifies parameter names is via the <code>info</code> endpoint, which also provides size details for each parameter (scalar or array, and array size if needed). The size of each parameter must be used to determine how many columns it will use in the CSV data. By not specifying a row of column names, HAPI avoids the need to have a naming convention for columns representing elements within an array parameter.</p>
    </div>
    <div class="section">
      <h1><a name="implications-of-the-hapi-data-model" number="5" class="hanchor" href="#implications-of-the-hapi-data-model">5 Implications of the HAPI data model</a></h1>
      <p>Because HAPI requires a single time column to be the first column, this requires each record (one row of data) to be associated with one-time value (the first value in the row). This has implications for serving files with multiple time arrays in them. Supposed a file contains 1-second data, 3-second data, and 5-second data, all from the same measurement but averaged differently. A HAPI server could expose this data, but not as a single dataset. To a HAPI server, each time resolution could be presented as a separate dataset, each with its own unique time array.</p>
    </div>
    <div class="section">
      <h1><a name="cross-origin-resource-sharing" number="6" class="hanchor" href="#cross-origin-resource-sharing">6 Cross Origin Resource Sharing</a></h1>
      <p>Because of the increasing importance of JavaScript clients that use AJAX requests, HAPI servers are strongly encouraged to implement Cross-Origin Resource Sharing (CORS) <a href="https://www.w3.org/TR/cors/">https://www.w3.org/TR/cors/</a>. This will allow AJAX requests by browser clients from any domain. For servers with only public data, enabling CORS is fairly common, and not implementing CORS limits the type of clients that can interface with a HAPI server. Server implementors are strongly encouraged to pursue a deeper understanding before proceeding with CORS. For testing purposes, the following headers have been sufficient for browser clients to HAPI servers:</p>
      <pre><code>Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: GET
Access-Control-Allow-Headers: Content-Type</code></pre>
    </div>
    <div class="section">
      <h1><a name="hapi-status-codes" number="7" class="hanchor" href="#hapi-status-codes">7 HAPI Status Codes</a></h1>
      <p>There are two ways that HAPI servers must report errors, and these must be consistent. Because every HAPI server response is an HTTP response, an appropriate HTTP status and message must be set for each response. The HTTP integer status codes to use are the standard ones (200 means OK, 404 means not found, etc), and these are listed below.</p>
      <p>The text message in the HTTP status should not just be the standard HTTP message but should include a HAPI-specific message, and this text should include the HAPI integer code along with the corresponding HAPI status message for that code. These HAPI codes and messages are also are described below. Note the careful use of “must” and “should” here. The use of the HTTP header message to include HAPI-specific details is optional, but the setting of the HTTP integer code status is required.</p>
      <p><a name="HTTPStatusExample"></a> As an example, it is recommended that a status message such as</p>
      <pre><code>HTTP/1.1 404 Not Found</code></pre>
      <p>is modified to include the HAPI error code and error message (as described below)</p>
      <pre><code>HTTP/1.1 404 Not Found; HAPI 1402 Bad request - error in start time</code></pre>
      <p>Although the HTTP status mechanism is robust, it is more difficult for some clients to access – a HAPI client using a high-level URL retrieving mechanism may not have easy access to HTTP header content. Therefore the HAPI response itself must also include a status indicator. This indicator appears as a <code>status</code> object in the HAPI header. The two status indicators (HAPI and HTTP) must be consistent, i.e., if one indicates success, so must the other. Note that some HAPI responses do not include a header, and in these cases, the HTTP header is the only place to obtain the status.</p>
      <p>The HAPI <code>status</code> object is described as follows:</p>
      <table>
        <thead>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>code</td>
            <td>integer</td>
            <td>Specific value indicating the category of the outcome of the request - see <a href="#hapi-status-codes">HAPI Status Codes</a>.</td>
          </tr>
          <tr>
            <td>message</td>
            <td>string</td>
            <td>Human readable description of the status - must conceptually match the intent of the integer code.</td>
          </tr>
        </tbody>
      </table>
      <p>HAPI servers must categorize the response status using at least the following three status codes: <code>1200 - OK</code>, <code>1400 - Bad Request</code>, and <code>1500 - Internal Server Error</code>. These are intentionally analogous to the similar HTTP codes <code>200 - OK</code>, <code>400 - Bad Request</code>, and <code>500 - Internal Server Error</code>. Note that HAPI code numbers are 1000 higher than the HTTP codes to avoid collisions. For these three simple subtracting 1000. The following table summarizes the minimum required status response categories.</p>
      <table>
        <thead>
          <tr>
            <th>HTTP code</th>
            <th>HAPI status <code>code</code></th>
            <th>HAPI status <code>message</code></th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>200</td>
            <td>1200</td>
            <td>OK</td>
          </tr>
          <tr>
            <td>400</td>
            <td>1400</td>
            <td>Bad request - user input error</td>
          </tr>
          <tr>
            <td>500</td>
            <td>1500</td>
            <td>Internal server error</td>
          </tr>
        </tbody>
      </table>
      <p>The exact wording in the HAPI message does not need to match what is shown here. The conceptual message must be consistent with the status, but the wording is allowed to be different (or in another language, for example). If the server is also including the HAPI error message in the HTTP status message (recommended, not required), the HTTP status wording should be as similar as possible to the HAPI message wording.</p>
      <p>The <code>about</code>, <code>capabilities</code> and <code>catalog</code> endpoints just need to indicate <code>1200 - OK</code> or <code>1500 - Internal Server Error</code> since they do not take any request parameters. The <code>info</code> and <code>data</code> endpoints do take request parameters, so their status response must include <code>1400 - Bad Request</code> when appropriate.</p>
      <p>A response of “1400 - Bad Request” must also be given when the user requests an endpoint that does not exist.</p>
      <p>Servers may optionally provide a more specific error code for the following common types of input processing problems. For convenience, a JSON object with these error codes is given in <a href="#appendix-b-json-object-of-hapi-response-and-error-codes">Appendix B</a>. It is recommended but not required that a server implement this more complete set of status responses. Servers may add their own codes but must use numbers outside the 1200s, 1400s, and 1500s to avoid collisions with possible future HAPI codes.</p>
      <table>
        <thead>
          <tr>
            <th>HTTP code</th>
            <th>HAPI status <code>code</code></th>
            <th>HAPI status <code>message</code></th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>200</td>
            <td>1200</td>
            <td>OK</td>
          </tr>
          <tr>
            <td>200</td>
            <td>1201</td>
            <td>OK - no data for time range</td>
          </tr>
          <tr>
            <td>400</td>
            <td>1400</td>
            <td>Bad request - user input error</td>
          </tr>
          <tr>
            <td>400</td>
            <td>1401</td>
            <td>Bad request - unknown API parameter name</td>
          </tr>
          <tr>
            <td>400</td>
            <td>1402</td>
            <td>Bad request - error in start time</td>
          </tr>
          <tr>
            <td>400</td>
            <td>1403</td>
            <td>Bad request - error in stop time</td>
          </tr>
          <tr>
            <td>400</td>
            <td>1404</td>
            <td>Bad request - start time equal to or after stop time</td>
          </tr>
          <tr>
            <td>400</td>
            <td>1405</td>
            <td>Bad request - time outside valid range</td>
          </tr>
          <tr>
            <td>404</td>
            <td>1406</td>
            <td>Bad request - unknown dataset id</td>
          </tr>
          <tr>
            <td>404</td>
            <td>1407</td>
            <td>Bad request - unknown dataset parameter</td>
          </tr>
          <tr>
            <td>400</td>
            <td>1408</td>
            <td>Bad request - too much time or data requested</td>
          </tr>
          <tr>
            <td>400</td>
            <td>1409</td>
            <td>Bad request - unsupported output format</td>
          </tr>
          <tr>
            <td>400</td>
            <td>1410</td>
            <td>Bad request - unsupported include value</td>
          </tr>
          <tr>
            <td>500</td>
            <td>1500</td>
            <td>Internal server error</td>
          </tr>
          <tr>
            <td>500</td>
            <td>1501</td>
            <td>Internal server error - upstream request error</td>
          </tr>
        </tbody>
      </table>
      <p>Note that there is an OK status to indicate that the request was properly fulfilled, but that no data was found. This can be very useful feedback to clients and users, who may otherwise suspect server problems if no data is returned.</p>
      <p>Note also the response 1408 indicating that the server will not fulfill the request since it is too large. This gives a HAPI server a way to let clients know about internal limits within the server.</p>
      <p>For errors that prevent any HAPI content from being returned (such as a 400 “not found” or 500 “internal server error”) the HAPI server should return a JSON object that is basically a HAPI header with just the status information. The JSON object should be returned even if the request was for non-JSON data. Returning server-specified content for an error response is also how HTTP servers handle error messages – think about custom HTML content that accompanies the 404 “not found” response when asking a server for a data file that does not exist.</p>
      <p>In cases where the server cannot create a full response (such as an <code>info</code> request or <code>data</code> request for an unknown dataset), the JSON header response must include the HAPI version and a HAPI status object indicating that an error has occurred.</p>
      <pre class="language-javascript"><code class="language-javascript">{
  <span class="hljs-string">"HAPI"</span>: <span class="hljs-string">"3.0"</span>,
  <span class="hljs-string">"status"</span>: { <span class="hljs-string">"code"</span>: <span class="hljs-number">1401</span>, <span class="hljs-string">"message"</span>: <span class="hljs-string">"Bad request - unknown request parameter"</span>}
}</code></pre>
      <p>For a data request with no JSON header requested, the HTTP error will be the only indicator of a problem. Similarly, for the <code>data</code> endpoint, clients may request data with no JSON header, and in this case, the HTTP status is the only place a client can determine the response status.</p>
    </div>
    <div class="section">
      <h2><a name="hapi-client-error-handling" number="7.1" class="hanchor" href="#hapi-client-error-handling">7.1 HAPI Client Error Handling</a></h2>
      <p>Because web servers are not required to limit HTTP return codes to those in the above table, HAPI clients should be able to handle the full range of HTTP responses. Also, the HAPI server code may not be the only software to interact with a URL-based request from a HAPI server. There may be a load balancer or upstream request routing or caching mechanism in place. Therefore, it is a good client-side practice to be able to handle any HTTP errors.</p>
      <p>Also, recall that in a three-digit HTTP error code, the first digit is the main one client code should examine for determining the response status. Subsequent digits give a finer nuance to the error, but there may be variability between servers for the exact values of the seconds and third digits. HAPI servers are allowed to use more specific values for these second and third digits but must keep the first digit consistent with the table above.</p>
      <p>Consider the HTTP 204 error code, which represents “No data.” A HAPI server is allowed to return this code when no data was present over the time range indicated, but (per HTTP rules) it must only do so in cases where the HTTP body truly contains no data. A HAPI header would count as HTTP data, so the HTTP 204 code can only be sent by a server when the clients requested CSV or binary data with no header. Here is a sample HTTP response for this case:</p>
      <pre><code>HTTP/1.1 204 OK - no content; HAPI 1201 OK - no data for the time range</code></pre>
      <p>Regardless of whether the server uses a more specific HTTP code, the HAPI code embedded in the HTTP message must properly indicate the HAPI status.</p>
    </div>
    <div class="section">
      <h1><a name="representation-of-time" number="8" class="hanchor" href="#representation-of-time">8 Representation of Time</a></h1>
      <p>Time values are always strings, and the HAPI Time format is a subset of the ISO 8601 date and time format [1].</p>
      <p>The restriction on the ISO 8601 standard is that time must be represented as</p>
      <pre><code>yyyy-mm-ddThh:mm:ss.sssZ</code></pre>
      <p>or</p>
      <pre><code>yyyy-dddThh:mm:ss.sssZ</code></pre>
      <p>and the trailing <code>Z</code> is required. Strings with less precision are allowed as per ISO 8601, e.g., <code>1999-01Z</code> and <code>1999-001Z</code>. The <a href="https://github.com/hapi-server/verifier-nodejs/blob/master/schemas/HAPI-data-access-schema-2.1.json">HAPI JSON schema</a> lists a series of regular expressions that codifies the intention of the HAPI Time specification. The schema allows leap seconds and hour=24, but it should be expected that not all clients will be able to properly interpret such time stamps.</p>
      <p>The name of the time parameter is not constrained by this specification. However, it is strongly recommended that the time column name be “Time” or “Epoch” or some easily recognizable label.</p>
    </div>
    <div class="section">
      <h2><a name="incoming-time-values" number="8.1" class="hanchor" href="#incoming-time-values">8.1 Incoming time values</a></h2>
      <p>Servers must require incoming time values from clients (i.e., the <code>start</code> and <code>stop</code> values on a data request) to be valid ISO 8601 time values. The full ISO 8601 specification allows many esoteric options, but servers must only accept a subset of the full ISO 8601 specification, namely one of either year-month-day (<code>yyyy-mm-ddThh:mm:ss.sssZ</code>) or day-of-year (<code>yyyy-dddThh:mm:ss.sssZ</code>). Any date or time elements missing from the string are assumed to take on their smallest possible value. For example, the string <code>2017-01-15T23:00:00.000Z</code> could be given in truncated form as <code>2017-01-15T23Z</code>. Servers should be able to parse and properly interpret these truncated time strings. When clients provide a date at day resolution only, the T must not be included, so servers should be able to parse day-level time strings without the T, as in <code>2017-01-15Z</code>.</p>
      <p>Note that in the ISO 8601 specification, a trailing Z on the time string indicates that no time zone offset should be applied (so the time zone is GMT+0). If a server receives an input value without the trailing Z, it should still interpret the time zone as GMT+0 rather than a local time zone. This is true for time strings with all fields present and for truncated time strings with some fields missing.</p>
      <table>
        <thead>
          <tr>
            <th>Example time range request</th>
            <th>comments</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>start=2017-01-15T00:00:00.000Z&amp;stop=2017-01-16T00:00.000Z</code></td>
            <td>OK - fully specified time value with proper trailing Z</td>
          </tr>
          <tr>
            <td><code>start=2017-01-15Z&amp;stop=2017-01-16Z</code></td>
            <td>OK - truncated time value that assumes 00:00.000 for the time</td>
          </tr>
          <tr>
            <td><code>start=2017-01-15&amp;stop=2017-01-16</code></td>
            <td>OK - truncated with missing trailing Z, but GMT+0 should be assumed</td>
          </tr>
        </tbody>
      </table>
      <p>There is no restriction on the earliest date or latest date a HAPI server can accept, but as a practical limit, clients are likely to be written to handle dates only in the range from years 1700 to 2100.</p>
    </div>
    <div class="section">
      <h2><a name="outgoing-time-values" number="8.2" class="hanchor" href="#outgoing-time-values">8.2 Outgoing time values</a></h2>
      <p>Time values in the outgoing data stream must be ISO 8601 strings. A server may use one of either the <code>yyyy-mm-ddThh:mm:ss.sssZ</code> or the <code>yyyy-dddThh:mm:ss.sssZ</code> form, but must use one format and length within any given dataset. The time values must not have any local time zone offset, and they must indicate this by including the trailing Z. Time or date elements may be omitted from the end to indicate that the missing time or date elements should be given their lowest possible value. For date values at day resolution (i.e., no time values), the T must be omitted, but the Z is still required. Note that this implies that clients must be able to parse potentially truncated ISO strings of both Year-Month-Day and Year-Day-of-year flavors. </p>
      <p>For <code>binary</code> and <code>csv</code> data, the length of time string, truncated or not, is indicated with the <code>length</code> attribute for the time parameter, which refers to the number of printable characters in the string. Every time string must have the same length and so padding of time strings is not needed.</p>
      <p>The data returned from a request should strictly fall within the limits of <code>start</code> and <code>stop</code>, i.e., servers should not pad the data with extra records outside the requested time range. Furthermore, note that the <code>start</code> value is inclusive (data at or beyond this time can be included), while <code>stop</code> is exclusive (data at or beyond this time shall not be included in the response).</p>
      <p>The primary time column is not allowed to contain any fill values. Each record must be identified with a valid time value. If other columns contain parameters of type <code>isotime</code> (i.e., time columns that are not the primary time column), there may be fill values in these columns. Note that the <code>fill</code> definition is required for all types, including <code>isotime</code> parameters. The fill value for a (non-primary) <code>isotime</code> parameter does not have to be a valid time string - it can be any string, but it must be the same length string as the time variable.</p>
      <p>Note that the ISO 8601 time format allows arbitrary precision on the time values. HAPI servers should therefore also accept time values with high precision. As a practical limit, servers should at least handle time values down to the nanosecond or picosecond level.</p>
      <p>HAPI metadata (in the <code>info</code> header for a dataset) allows a server to specify where timestamps fall within the measurement window. The <code>timeStampLocation</code> attribute for a dataset is an enumeration with possible values of <code>begin</code>, <code>center</code>, <code>end</code>, or <code>other</code>. This attribute is optional, but the default value is <code>center</code>, which refers to the exact middle of the measurement window. If the location of the timestamp is not known or is more complex than any of the allowed options, the server can report <code>other</code> for the <code>timeStampLocation</code>. Clients are likely to use <code>center</code> for <code>other</code>, simply because there is not much else they can do. Note that the optional <code>cadence</code> attribute is not meant to be accurate enough to use as a way to compute an alternate time stamp location. In other words, given a <code>timeStampLocation</code> of <code>begin</code> and a <code>cadence</code> of 10 seconds, it may not always work to just add 5 seconds to get to the center of the measurement interval for this dataset. This is because the <code>cadence</code> provides a nominal duration, and the actual duration of each measurement may vary significantly throughout the dataset. Some datasets may have specific parameters devoted to accumulation time or other measurement window parameters, but HAPI metadata does not capture this level of measurement window details. Suggestions on handling the issues discussed in this paragraph are given on the <a href="https://github.com/hapi-server/data-specification/wiki/Implementation-Notes#Durations">implementation notes</a> page.</p>
    </div>
    <div class="section">
      <h1><a name="additional-keyword-value-pairs" number="9" class="hanchor" href="#additional-keyword-value-pairs">9 Additional Keyword / Value Pairs</a></h1>
      <p>While the HAPI server strictly checks all request parameters (servers must return an error code given any unrecognized request parameter as described earlier), the JSON content output by a HAPI server may contain additional, user-defined metadata elements. All non-standard metadata keywords must begin with the prefix <code>x_</code> to indicate to HAPI clients that these are extensions. Custom clients could make use of the additional keywords, but standard clients would ignore the extensions. By using the standard prefix, the custom keywords will not conflict with any future keywords added to the HAPI standard. Servers using these extensions may wish to include additional, domain-specific characters after the <code>x_</code> to avoid possible collisions with extensions from other servers.</p>
    </div>
    <div class="section">
      <h1><a name="more-about" number="10" class="hanchor" href="#more-about">10 More About</a></h1>
    </div>
    <div class="section">
      <h2><a name="data-types" number="10.1" class="hanchor" href="#data-types">10.1 Data Types</a></h2>
      <p>Note that there are only a few supported data types: <code>isotime</code>, <code>string</code>, <code>integer</code>, and <code>double</code>. This is intended to keep the client code simple in terms of dealing with the data stream. However, the spec may be expanded in the future to include other types, such as 4-byte floating-point values (which would be called float), or 2-byte integers (which would be called short).</p>
    </div>
    <div class="section">
      <h2><a name="the-size-attribute" number="10.2" class="hanchor" href="#the-size-attribute">10.2 The ‘size’ Attribute</a></h2>
      <p>The ‘size’ attribute is required for array parameters and not allowed for others. The length of the <code>size</code> array indicates the number of dimensions, and each element in the size array indicates the number of elements in that dimension. For example, the size attribute for a 1-D array would be a 1-D JSON array of length one, with the one element in the JSON array indicating the number of elements in the data array. For a spectrum, this number of elements is the number of wavelengths or energies in the spectrum. Thus <code>"size": [9]</code> refers to a data parameter that is a 1-D array of length 9, and in the <code>csv</code> and <code>binary</code> output formats, there will be 9 columns for this data parameter. In the <code>json</code> output for this data parameter, each record will contain a JSON array of 9 elements (enclosed in brackets <code>[ ]</code>).</p>
      <p>For arrays of size 2-D or higher, the column orderings need to be specified for the <code>csv</code> and <code>binary</code> output formats, because for both of these formats, the array needs to be “unrolled” into individual columns. The mapping of 2-D array element to unrolled column index is done so that the later array elements change the fastest. This is illustrated with the following example. Given a 2-D array of <code>"size":[2,5]</code>, the 5 item index changes the most quickly. Items in each record will be ordered like this <code>[0,0] [0,1], [0,2] [0,3] [0,4] [1,0,] [1,1] [1,2] [1,3] [1,4]</code> and the ordering is similarly done for higher dimensions.</p>
      <p>No unrolling is needed for JSON arrays because JSON syntax can represent arrays of any dimension. The following example shows one record of data with a time parameter and a single data parameter <code>"size":[2,5]</code> (of type double):</p>
      <pre><code>["2017-11-13T12:34:56.789Z", [ [0.0, 1.1, 2.2, 3.3, 4.4] [5.0,6.0,7.0,8.0,9.0] ] ]</code></pre>
    </div>
    <div class="section">
      <h2><a name="-fill-values" number="10.3" class="hanchor" href="#-fill-values">10.3 ‘fill’ Values</a></h2>
      <p>Note that fill values for all types must be specified as a string. For <code>double</code> and <code>integer</code> types, the string should correspond to a numeric value. In other words, using a string like <code>invalid_int</code> would not be allowed for an integer fill value. Care should be taken to ensure that the string value given will have an exact numeric representation, and special care should be taken for <code>double</code> values which can suffer from round-off problems. For integers, string fill values must correspond to an integer value that is small enough to fit into a 4-byte signed integer. For <code>double</code> parameters, the fill string must parse to an exact IEEE 754 double representation. One suggestion is to use large negative integers, such as <code>-1.0E30</code>. The string <code>NaN</code> is allowed, in which the case <code>csv</code> output should contain the string <code>NaN</code> for fill values. For double NaN values, the bit pattern for quiet NaN should be used, as opposed to the signaling NaN, which should not be used (see reference [6]). For <code>string</code> and <code>isotime</code> parameters, the string <code>fill</code> value is used at face value, and it should have a length that fits in the length of the data parameter.</p>
    </div>
    <div class="section">
      <h2><a name="examples" number="10.4" class="hanchor" href="#examples">10.4 Examples</a></h2>
      <p>The following two examples illustrate two different ways to represent a magnetic field dataset. The first lists a time column and three scalar data columns, Bx, By, and Bz for the Cartesian components.</p>
      <pre class="language-javascript"><code class="language-javascript">{
   <span class="hljs-string">"HAPI"</span>: <span class="hljs-string">"3.0"</span>,
   <span class="hljs-string">"status"</span>: { <span class="hljs-string">"code"</span>: <span class="hljs-number">1200</span>, <span class="hljs-string">"message"</span>: <span class="hljs-string">"OK"</span>},
   <span class="hljs-string">"startDate"</span>: <span class="hljs-string">"2016-01-01T00:00:00.000Z"</span>,
   <span class="hljs-string">"stopDate"</span>: <span class="hljs-string">"2016-01-31T24:00:00.000Z"</span>,
   <span class="hljs-string">"parameters"</span>: [
      {<span class="hljs-string">"name"</span> : <span class="hljs-string">"timestamp"</span>, <span class="hljs-string">"type"</span>: <span class="hljs-string">"isotime"</span>, <span class="hljs-string">"units"</span>: <span class="hljs-string">"UTC"</span>, <span class="hljs-string">"fill"</span>: <span class="hljs-literal">null</span>, <span class="hljs-string">"length"</span>: <span class="hljs-number">24</span>},
      {<span class="hljs-string">"name"</span> : <span class="hljs-string">"bx"</span>, <span class="hljs-string">"type"</span>: <span class="hljs-string">"double"</span>, <span class="hljs-string">"units"</span>: <span class="hljs-string">"nT"</span>, <span class="hljs-string">"fill"</span>: <span class="hljs-string">"-1e31"</span>},
      {<span class="hljs-string">"name"</span> : <span class="hljs-string">"by"</span>, <span class="hljs-string">"type"</span>: <span class="hljs-string">"double"</span>, <span class="hljs-string">"units"</span>: <span class="hljs-string">"nT"</span>, <span class="hljs-string">"fill"</span>: <span class="hljs-string">"-1e31"</span>},
      {<span class="hljs-string">"name"</span> : <span class="hljs-string">"bz"</span>, <span class="hljs-string">"type"</span>: <span class="hljs-string">"double"</span>, <span class="hljs-string">"units"</span>: <span class="hljs-string">"nT"</span>, <span class="hljs-string">"fill"</span>: <span class="hljs-string">"-1e31"</span>}
   ]
}</code></pre>
      <p>This example shows a header for the same conceptual data (time and three magnetic field components), but with the three components grouped into a one-dimensional array of size 3.</p>
      <pre class="language-javascript"><code class="language-javascript">{
   <span class="hljs-string">"HAPI"</span>: <span class="hljs-string">"3.0"</span>,
   <span class="hljs-string">"status"</span>: { <span class="hljs-string">"code"</span>: <span class="hljs-number">1200</span>, <span class="hljs-string">"message"</span>: <span class="hljs-string">"OK"</span>},
   <span class="hljs-string">"startDate"</span>: <span class="hljs-string">"2016-01-01T00:00:00.000Z"</span>,
   <span class="hljs-string">"stopDate"</span>: <span class="hljs-string">"2016-01-31T24:00:00.000Z"</span>,
   <span class="hljs-string">"parameters"</span>: [
      { <span class="hljs-string">"name"</span> : <span class="hljs-string">"timestamp"</span>, <span class="hljs-string">"type"</span>: <span class="hljs-string">"isotime"</span>, <span class="hljs-string">"units"</span>: <span class="hljs-string">"UTC"</span>, , <span class="hljs-string">"fill"</span>: <span class="hljs-literal">null</span>, <span class="hljs-string">"length"</span>: <span class="hljs-number">24</span> },
      { <span class="hljs-string">"name"</span> : <span class="hljs-string">"b_field"</span>, <span class="hljs-string">"type"</span>: <span class="hljs-string">"double"</span>, <span class="hljs-string">"units"</span>: <span class="hljs-string">"nT"</span>,, <span class="hljs-string">"fill"</span>: <span class="hljs-string">"-1e31"</span>, <span class="hljs-string">"size"</span>: [<span class="hljs-number">3</span>] }
   ]
}</code></pre>
      <p>These two different representations affect how a subset of parameters could be requested from a server. The first example, by listing Bx, By, and Bz as separate parameters, allows clients to request individual components:</p>
      <pre><code>http://server/hapi/data?dataset=MY_MAG_DATA&amp;start=2001Z&amp;stop=2010Z&amp;parameters=Bx</code></pre>
      <p>This request would just return a time column (always included as the first column) and a Bx column. But in the second example, the components are all inside a single parameter named <code>b_field</code> and so a request for this parameter must always return all the components of the parameter. There is no way to request individual elements of an array parameter.</p>
      <p>The following example shows a proton energy spectrum and illustrates the use of the ‘bins’ element. Note also that the uncertainty of the values associated with the proton spectrum is a separate variable. There is currently no way in the HAPI spec to explicitly link a variable to its uncertainties.</p>
      <pre class="language-javascript"><code class="language-javascript">{<span class="hljs-string">"HAPI"</span>: <span class="hljs-string">"3.0"</span>,
 <span class="hljs-string">"status"</span>: { <span class="hljs-string">"code"</span>: <span class="hljs-number">1200</span>, <span class="hljs-string">"message"</span>: <span class="hljs-string">"OK"</span>},
 <span class="hljs-string">"startDate"</span>: <span class="hljs-string">"2016-01-01T00:00:00.000Z"</span>,
 <span class="hljs-string">"stopDate"</span>: <span class="hljs-string">"2016-01-31T24:00:00.000Z"</span>,
 <span class="hljs-string">"parameters"</span>: [
   { <span class="hljs-string">"name"</span>: <span class="hljs-string">"Time"</span>,
     <span class="hljs-string">"type"</span>: <span class="hljs-string">"isotime"</span>,
     <span class="hljs-string">"units"</span>: <span class="hljs-string">"UTC"</span>,
     <span class="hljs-string">"fill"</span>: <span class="hljs-literal">null</span>,
     <span class="hljs-string">"length"</span>: <span class="hljs-number">24</span>
   },
   { <span class="hljs-string">"name"</span>: <span class="hljs-string">"qual_flag"</span>,
     <span class="hljs-string">"type"</span>: <span class="hljs-string">"int"</span>,
     <span class="hljs-string">"units"</span>: <span class="hljs-literal">null</span>,
     <span class="hljs-string">"fill"</span>: <span class="hljs-literal">null</span>
   },
   { <span class="hljs-string">"name"</span>: <span class="hljs-string">"maglat"</span>,
     <span class="hljs-string">"type"</span>: <span class="hljs-string">"double"</span>,
     <span class="hljs-string">"units"</span>: <span class="hljs-string">"degrees"</span>,
     <span class="hljs-string">"fill"</span>: <span class="hljs-literal">null</span>,
     <span class="hljs-string">"description"</span>: <span class="hljs-string">"magnetic latitude"</span>
   },
   { <span class="hljs-string">"name"</span>: <span class="hljs-string">"MLT"</span>,
     <span class="hljs-string">"type"</span>: <span class="hljs-string">"string"</span>,
     <span class="hljs-string">"length"</span>: <span class="hljs-number">5</span>,
     <span class="hljs-string">"units"</span>: <span class="hljs-string">"hours:minutes"</span>,
     <span class="hljs-string">"fill"</span>: <span class="hljs-string">"??:??"</span>,
     <span class="hljs-string">"description"</span>: <span class="hljs-string">"magnetic local time in HH:MM"</span>
   },
   { <span class="hljs-string">"name"</span>: <span class="hljs-string">"proton_spectrum"</span>,
     <span class="hljs-string">"type"</span>: <span class="hljs-string">"double"</span>,
     <span class="hljs-string">"size"</span>: [<span class="hljs-number">3</span>],
     <span class="hljs-string">"units"</span>: <span class="hljs-string">"particles/(sec ster cm^2 keV)"</span>,
     <span class="hljs-string">"fill"</span>: <span class="hljs-string">"-1e31"</span>,
     <span class="hljs-string">"bins"</span>: [ {
         <span class="hljs-string">"name"</span>: <span class="hljs-string">"energy"</span>,
         <span class="hljs-string">"units"</span>: <span class="hljs-string">"keV"</span>,
         <span class="hljs-string">"centers"</span>: [ <span class="hljs-number">15</span>, <span class="hljs-number">25</span>, <span class="hljs-number">35</span> ],
          } ],
   { <span class="hljs-string">"name"</span>: <span class="hljs-string">"proton_spectrum_uncerts"</span>,
     <span class="hljs-string">"type"</span>: <span class="hljs-string">"double"</span>,
     <span class="hljs-string">"size"</span>: [<span class="hljs-number">3</span>],
     <span class="hljs-string">"units"</span>: <span class="hljs-string">"particles/(sec ster cm^2 keV)"</span>,
     <span class="hljs-string">"fill"</span>: <span class="hljs-string">"-1e31"</span>,
     <span class="hljs-string">"bins"</span>: [ {
         <span class="hljs-string">"name"</span>: <span class="hljs-string">"energy"</span>,
         <span class="hljs-string">"units"</span>: <span class="hljs-string">"keV"</span>,
         <span class="hljs-string">"centers"</span>: [ <span class="hljs-number">15</span>, <span class="hljs-number">25</span>, <span class="hljs-number">35</span> ],
          } ]
   }

  ]
}</code></pre>
      <p>This shows how “ranges” can specify the bins:</p>
      <pre class="language-javascript"><code class="language-javascript">{
    <span class="hljs-string">"HAPI"</span>: <span class="hljs-string">"3.0"</span>,
    <span class="hljs-string">"status"</span>: { <span class="hljs-string">"code"</span>: <span class="hljs-number">1200</span>, <span class="hljs-string">"message"</span>: <span class="hljs-string">"OK"</span>},
    <span class="hljs-string">"startDate"</span>: <span class="hljs-string">"2016-01-01T00:00:00.000Z"</span>,
    <span class="hljs-string">"stopDate"</span>: <span class="hljs-string">"2016-01-31T24:00:00.000Z"</span>,
    <span class="hljs-string">"parameters"</span>: [
        {
            <span class="hljs-string">"length"</span>: <span class="hljs-number">24</span>,
            <span class="hljs-string">"name"</span>: <span class="hljs-string">"Time"</span>,
            <span class="hljs-string">"type"</span>: <span class="hljs-string">"isotime"</span>,
            <span class="hljs-string">"fill"</span>: <span class="hljs-literal">null</span>,
            <span class="hljs-string">"units"</span>: <span class="hljs-string">"UTC"</span>
        },
        {
            <span class="hljs-string">"bins"</span>: [{
                <span class="hljs-string">"ranges"</span>: [
                    [  <span class="hljs-number">0</span>,  <span class="hljs-number">30</span> ],
                    [  <span class="hljs-number">30</span>,  <span class="hljs-number">60</span> ],
                    [  <span class="hljs-number">60</span>,  <span class="hljs-number">90</span> ],
                    [  <span class="hljs-number">90</span>,  <span class="hljs-number">120</span> ],
                    [  <span class="hljs-number">120</span>,  <span class="hljs-number">150</span> ],
                    [  <span class="hljs-number">150</span>,  <span class="hljs-number">180</span> ]
                ],
                <span class="hljs-string">"units"</span>: <span class="hljs-string">"degrees"</span>
            }],
            <span class="hljs-string">"fill"</span>: <span class="hljs-string">"-1e31"</span>,
            <span class="hljs-string">"name"</span>: <span class="hljs-string">"pitchAngleSpectrum"</span>,
            <span class="hljs-string">"size"</span>: [<span class="hljs-number">6</span>],
            <span class="hljs-string">"type"</span>: <span class="hljs-string">"double"</span>,
        <span class="hljs-string">"units"</span>: <span class="hljs-string">"particles/sec/cm^2/ster/keV"</span>
        }
    ]
}</code></pre>
    </div>
    <div class="section">
      <h1><a name="security-notes" number="11" class="hanchor" href="#security-notes">11 Security Notes</a></h1>
      <p>When the server sees a request parameter that it does not recognize, it should throw an error.</p>
      <p>So given this query</p>
      <pre><code>http://server/hapi/data?dataset=DATA&amp;start=T1&amp;stop=T2&amp;fields=mag_GSE&amp;avg=5s</code></pre>
      <p>the server should throw an error with a status of <code>1400 - Bad Request</code> with an HTTP status of 400. The server could optionally be more specific with <code>1401 - misspelled or invalid request parameter</code> with an HTTP code of <code>404 - Not Found</code>.</p>
      <p>In following general security practices, HAPI servers should carefully screen incoming request parameter name values. Unknown request parameters and values, including incorrectly formatted time values, should <strong>not</strong> be echoed in the error response.</p>
    </div>
    <div class="section">
      <h1><a name="adoption" number="12" class="hanchor" href="#adoption">12 Adoption</a></h1>
      <p>In terms of adopting HAPI as a data delivery mechanism, data providers will likely not want to change existing services, so a HAPI-compliant access mechanism could be added alongside existing services. Several demonstration servers exist, but there are not yet any libraries or tools available for providers to use or adapt. These will be made available as they are created. The goal is to create a reference implementation as a full-fledged example that providers could adapt. On the client-side, there are also demonstration level capabilities, and Autoplot currently can access HAPI compliant servers. Eventually, libraries in several languages will be made available to assist in writing clients that extract data from HAPI servers. However, even without example code, the HAPI specification is designed to be simple enough so that even small data providers could add HAPI compliant access to their holdings.</p>
    </div>
    <div class="section">
      <h1><a name="references" number="13" class="hanchor" href="#references">13 References</a></h1>
      <p>[1] ISO 8601:2019 Date Time Format Standard, <a href="https://www.iso.org/standard/70908.html">https://www.iso.org/standard/70908.html</a></p>
      <p>[2] CSV format, <a href="https://tools.ietf.org/html/rfc4180">https://tools.ietf.org/html/rfc4180</a> </p>
      <p>[3] JSON Format, <a href="https://tools.ietf.org/html/rfc7159">https://tools.ietf.org/html/rfc7159</a>; <a href="http://json-schema.org/">http://json-schema.org/</a><br>[4] IEEE Standard for Floating-Point Arithmetic, <a href="http://doi.org/10.1109/IEEESTD.2008.4610935">http://doi.org/10.1109/IEEESTD.2008.4610935</a></p>
      <p>[5] Understanding JSON Schema - Structuring a Complex Schema, <a href="https://json-schema.org/understanding-json-schema/structuring.html">https://json-schema.org/understanding-json-schema/structuring.html</a></p>
    </div>
    <div class="section">
      <h1><a name="contact" number="14" class="hanchor" href="#contact">14 Contact</a></h1>
      <p>Todd King (tking@igpp.ucla.edu)<br>Jon Vandegriff (jon.vandegriff@jhuapl.edu)<br>Robert Weigel (rweigel@gmu.edu)<br>Robert Candey (Robert.M.Candey@nasa.gov)<br>Aaron Roberts (aaron.roberts@nasa.gov)<br>Bernard Harris (bernard.t.harris@nasa.gov)<br>Nand Lal (nand.lal-1@nasa.gov)<br>Jeremy Faden (faden@cottagesystems.com)</p>
    </div>
    <div class="section">
      <h1><a name="appendix-a-sample-landing-page" number="15" class="hanchor" href="#appendix-a-sample-landing-page">15 Appendix A: Sample Landing Page</a></h1>
      <p>See <a href="https://github.com/hapi-server/server-ui">https://github.com/hapi-server/server-ui</a></p>
    </div>
    <div class="section">
      <h1><a name="appendix-b-json-object-of-hapi-response-and-error-codes" number="16" class="hanchor" href="#appendix-b-json-object-of-hapi-response-and-error-codes">16 Appendix B: JSON Object of HAPI Response and Error Codes</a></h1>
      <pre class="language-javascript"><code class="language-javascript">{
    <span class="hljs-string">"1200"</span>: {<span class="hljs-string">"status"</span>:{<span class="hljs-string">"code"</span>: <span class="hljs-number">1200</span>, <span class="hljs-string">"message"</span>: <span class="hljs-string">"HAPI 1200: OK"</span>}},
    <span class="hljs-string">"1201"</span>: {<span class="hljs-string">"status"</span>:{<span class="hljs-string">"code"</span>: <span class="hljs-number">1201</span>, <span class="hljs-string">"message"</span>: <span class="hljs-string">"HAPI 1201: OK - no data"</span>}},
    <span class="hljs-string">"1400"</span>: {<span class="hljs-string">"status"</span>:{<span class="hljs-string">"code"</span>: <span class="hljs-number">1400</span>, <span class="hljs-string">"message"</span>: <span class="hljs-string">"HAPI error 1400: user input error"</span>}},
    <span class="hljs-string">"1401"</span>: {<span class="hljs-string">"status"</span>:{<span class="hljs-string">"code"</span>: <span class="hljs-number">1401</span>, <span class="hljs-string">"message"</span>: <span class="hljs-string">"HAPI error 1401: unknown API parameter name"</span>}},
    <span class="hljs-string">"1402"</span>: {<span class="hljs-string">"status"</span>:{<span class="hljs-string">"code"</span>: <span class="hljs-number">1402</span>, <span class="hljs-string">"message"</span>: <span class="hljs-string">"HAPI error 1402: error in start"</span>}},
    <span class="hljs-string">"1403"</span>: {<span class="hljs-string">"status"</span>:{<span class="hljs-string">"code"</span>: <span class="hljs-number">1403</span>, <span class="hljs-string">"message"</span>: <span class="hljs-string">"HAPI error 1403: error in stop"</span>}},
    <span class="hljs-string">"1404"</span>: {<span class="hljs-string">"status"</span>:{<span class="hljs-string">"code"</span>: <span class="hljs-number">1404</span>, <span class="hljs-string">"message"</span>: <span class="hljs-string">"HAPI error 1404: start equal to or after stop"</span>}},
    <span class="hljs-string">"1405"</span>: {<span class="hljs-string">"status"</span>:{<span class="hljs-string">"code"</span>: <span class="hljs-number">1405</span>, <span class="hljs-string">"message"</span>: <span class="hljs-string">"HAPI error 1405: time outside valid range"</span>}},
    <span class="hljs-string">"1406"</span>: {<span class="hljs-string">"status"</span>:{<span class="hljs-string">"code"</span>: <span class="hljs-number">1406</span>, <span class="hljs-string">"message"</span>: <span class="hljs-string">"HAPI error 1406: unknown dataset id"</span>}},
    <span class="hljs-string">"1407"</span>: {<span class="hljs-string">"status"</span>:{<span class="hljs-string">"code"</span>: <span class="hljs-number">1407</span>, <span class="hljs-string">"message"</span>: <span class="hljs-string">"HAPI error 1407: unknown dataset parameter"</span>}},
    <span class="hljs-string">"1408"</span>: {<span class="hljs-string">"status"</span>:{<span class="hljs-string">"code"</span>: <span class="hljs-number">1408</span>, <span class="hljs-string">"message"</span>: <span class="hljs-string">"HAPI error 1408: too much time or data requested"</span>}},
    <span class="hljs-string">"1409"</span>: {<span class="hljs-string">"status"</span>:{<span class="hljs-string">"code"</span>: <span class="hljs-number">1409</span>, <span class="hljs-string">"message"</span>: <span class="hljs-string">"HAPI error 1409: unsupported output format"</span>}},
    <span class="hljs-string">"1410"</span>: {<span class="hljs-string">"status"</span>:{<span class="hljs-string">"code"</span>: <span class="hljs-number">1410</span>, <span class="hljs-string">"message"</span>: <span class="hljs-string">"HAPI error 1410: unsupported include value"</span>}},
    <span class="hljs-string">"1411"</span>: {<span class="hljs-string">"status"</span>:{<span class="hljs-string">"code"</span>: <span class="hljs-number">1411</span>, <span class="hljs-string">"message"</span>: <span class="hljs-string">"HAPI error 1411: out-of-order or duplicate parameters"</span>}},
    <span class="hljs-string">"1412"</span>: {<span class="hljs-string">"status"</span>:{<span class="hljs-string">"code"</span>: <span class="hljs-number">1412</span>, <span class="hljs-string">"message"</span>: <span class="hljs-string">"HAPI error 1412: unsupported resolve_references value"</span>}},
    <span class="hljs-string">"1500"</span>: {<span class="hljs-string">"status"</span>:{<span class="hljs-string">"code"</span>: <span class="hljs-number">1500</span>, <span class="hljs-string">"message"</span>: <span class="hljs-string">"HAPI error 1500: internal server error"</span>}},
    <span class="hljs-string">"1501"</span>: {<span class="hljs-string">"status"</span>:{<span class="hljs-string">"code"</span>: <span class="hljs-number">1501</span>, <span class="hljs-string">"message"</span>: <span class="hljs-string">"HAPI error 1501: upstream request error"</span>}}
}</code></pre>
    </div>
  </div>
</body>

</html>